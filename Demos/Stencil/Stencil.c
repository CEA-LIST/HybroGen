/* Begin Header autogenerated part */
#ifndef H2_COMMON
#define H2_COMMON
/* Common HybroGen inserted code */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdint.h>

bool h2_codeGenerationOK;	 // Does code generation fail ?
typedef int32_t h2_regSet_t; // Register set (signed, use -1 when not allocated)
typedef unsigned long long ticks_t;
static  ticks_t h2_start_codeGen, h2_end_codeGen;

typedef struct
{
  int ValOrReg; // is register or immediate value ?
  char arith;   // int, flt or other arithmetic
  int vLen;     // vector len
  int wLen;     // word len
  int regNro;   // register number (if register)
  int valueImm; // immediate value (if not register)
} h2_sValue_t;

typedef enum { REGISTER,    VALUE, } VALORREG;

typedef union {
    float f;
    unsigned long i;
} h2_float_int_u;

static int h2_log2(int value)
{ // integer logarithm
  int log = 0;
  while (value >>= 1) { ++log; }
  return log;
}

void printRev (int value, int pos)
{ // Print a bitset in reversal order (recursive)
  if (pos != 0)
	printRev (value >> 1, pos - 1);
  printf ("%1c", (value % 2)?'.':'F');
}

// Dynamic register allocation handling
// h2_regSet mask : 0 mean free register, 1 register set
//  3           2            1  Bit position = reg Number
// 1098 7654 3210 9876 5432 1098 7654 3210
// 1111 1111 1111 1111 0000 0001 0011 1111
typedef struct
{	// Register allocation sets for
  	// int, float, vector of ints, vector of floats
  int intSet, fltSet, vintSet, vfltSet ;
} h2_RegSets_t;

h2_RegSets_t h2_regSet, h2_regSetInit;

// Print integer register set
void printRegState(char * msg, int regNo, int registerSet)
{
  int count = 8 * sizeof (registerSet) - 1;
  h2_regSet_t tmpReg = registerSet;
  printf ("%02d : Reg %s\n", regNo, msg);
  for (int i = count; i >= 0; i--) // Tens
	(0 == (i % 10))?printf ("%d", i/10):printf (" ");
  printf ("\n");
  for (int i = count; i >= 0; i--) // Unit
	  printf ("%d", i%10);
  printf ("\n");
  printRev (tmpReg, count); // Bit set
  printf ("\n");
}

// Initialize registers sets allocation
static void h2_initRegisterMasks(int intmask, int fltmask, int vectorintmask, int vectorfltmask)
{ // See H2SymbolTable & H2RegisterBank
  h2_regSetInit.intSet  = intmask;
  h2_regSetInit.fltSet  = fltmask;
  h2_regSetInit.vintSet = vectorintmask;
  h2_regSetInit.vfltSet = vectorfltmask;
}

static void h2_resetRegisterMasks() // Reset register set from initializers
{
  h2_regSet.intSet  = h2_regSetInit.intSet;
  h2_regSet.fltSet  = h2_regSetInit.fltSet;
  h2_regSet.vintSet = h2_regSetInit.vintSet;
  h2_regSet.vfltSet = h2_regSetInit.vfltSet;
#ifdef H2_DEBUG_REGISTER
  printRegState("RESET", -1, h2_regSet.intSet);
#endif // H2_DEBUG_REGISTER
}
int h2_getReg () // Get new register
{
  /* Search for the 1st free register */
  h2_regSet_t tmpReg = h2_regSet.intSet;
  for (int i = 0; i < 8 * sizeof (h2_regSet.intSet); i++)
	{
	  if (tmpReg % 2 == 0)
		{						/* Free register found */
		  h2_regSet.intSet = h2_regSet.intSet | (1 << i); /* Update regSet */
#ifdef H2_DEBUG_REGISTER
		  printRegState("GET", i, h2_regSet.intSet);
#endif // H2_DEBUG_REGISTER
		  return i;
		}
	  tmpReg >>= 1;
	}
  printf ("Register allocation failed\n");
  h2_codeGenerationOK = false;
  return -1;
}

void h2_freeReg (h2_regSet_t v) // Free a register
{
#if 1 // TODO : To be rethinked
  // Is the register freeable ?
  int isOK = (h2_regSetInit.intSet >> v) & 1;
  if (0 == isOK)
    {
	h2_regSet.intSet = h2_regSet.intSet & ~(1 << v); /* Update regSet */
#ifdef H2_DEBUG_REGISTER
    printRegState("FREE", v, h2_regSet.intSet);
#endif // H2_DEBUG_REGISTER
    }
#endif
}
#endif /*H2_COMMON*/
#ifndef H2_AARCH64
#define H2_AARCH64

#define H2SYS 					/* Has  operating system */

#ifdef H2SYS
#include <sys/mman.h>
#endif

typedef uint32_t   h2_insn_t;
static  h2_insn_t  *h2_asm_pc;
static  h2_insn_t  *h2_save_asm_pc;
#define H2Aarch64SP  (h2_sValue_t) {REGISTER, 'i', 1, 32, 31, 0}
/* aarch64 / power examples :
   https://github.com/FFTW/fftw3/blob/master/kernel/cycle.h */

static inline ticks_t h2_getticks(void)
{
  uint64_t Rt;
  asm volatile("mrs %0,  CNTVCT_EL0" : "=r" (Rt));
  return Rt;
}

static void h2_iflush(void *addr, void *last)
{
#ifdef H2SYS
  __clear_cache((char *)addr, (char *)last); // Flush data cache where binary code were written
  long pageSize= getpagesize();              // Make the page executable
  void *ptmp= (char *)((long)addr & ~(pageSize - 1));
  if (mprotect(ptmp, (last - addr), PROT_READ | PROT_WRITE | PROT_EXEC))
    {
      perror("iflush: mprotect");
      exit(-1);
    }
#endif
#ifdef H2_DEBUG
	uint64_t codeGenDuration = h2_end_codeGen - h2_start_codeGen;
	uint64_t insnGenerated = (last-addr)/sizeof (h2_insn_t);
    printf ("Flush data cache from %p to %p\n", addr, last);
	printf ("%ld insn generated in %ld ticks. %ld ticks / insn\n", insnGenerated, codeGenDuration, codeGenDuration/insnGenerated);
#endif
	if (!h2_codeGenerationOK)
	  {
		fprintf (stderr, "(iflush) Failed code generation\n");
		exit(-5);
	  }
}

static h2_insn_t *h2_malloc (size_t size)
{
  return malloc (size);
}


#endif /* H2_AARCH64 */
/* In memory instruction generator */
#define aarch64_G32(INSN){ *(h2_asm_pc++) = (INSN);}

/* Single instruction binary code generator*/
#define A64_RET__I_64_1() do /* ret */ { 	aarch64_G32(((0xd65f03c0 >> 0) & 0xffffffff)); \
 } while(0);
#define A64_STRB_RRI_I_8_1(r0,r1,i0) do /* w */ { 	aarch64_G32(((0x1c0 & 0x7ff) << 21)|((i0 & 0x1ff) << 12)|((0x1 & 0x3) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0)); } while(0);
#define A64_STRH_RRI_I_16_1(r0,r1,i0) do /* w */ { 	aarch64_G32(((0x3c0 & 0x7ff) << 21)|((i0 & 0x1ff) << 12)|((0x1 & 0x3) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0)); } while(0);
#define A64_ST1_RRI_I_32_4(r0,r1,i0) do /* w */ { 	aarch64_G32(((0x130 & 0x3ff) << 22)|((i0 & 0x3f) << 16)|((0x1e & 0x3f) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0)); } while(0);
#define A64_STR_RRI_I_32_1(r0,r1,i0) do /* w */ { 	aarch64_G32(((0x5c0 & 0x7ff) << 21)|((i0 & 0x1ff) << 12)|((0x1 & 0x3) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0)); } while(0);
#define A64_ST1_RR_I_32_4(r0,r1) do /* w */ { 	aarch64_G32(((0x13001e & 0x3fffff) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0)); } while(0);
#define A64_STR_RRR_I_32_1(r0,r1,r2) do /* w */ { 	aarch64_G32(((0x5c1 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x36 & 0x3f) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0)); } while(0);
#define A64_STR_RRI_I_32_2(r0,r1,i0) do /* w */ { 	aarch64_G32(((0x7e0 & 0x7ff) << 21)|((i0 & 0x1ff) << 12)|((0x0 & 0x3) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0)); } while(0);
#define A64_STR_RRI_I_64_1(r0,r1,i0) do /* w */ { 	aarch64_G32(((0x7c0 & 0x7ff) << 21)|((i0 & 0x1ff) << 12)|((0x1 & 0x3) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0)); } while(0);
#define A64_STR_RRR_I_64_1(r0,r1,r2) do /* w */ { 	aarch64_G32(((0x7c1 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x36 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MUL_RRR_I_8_8(r0,r1,r2) do /* mul */ { 	aarch64_G32(((0x71 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MUL_RRR_I_8_16(r0,r1,r2) do /* mul */ { 	aarch64_G32(((0x271 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MUL_RRR_I_16_4(r0,r1,r2) do /* mul */ { 	aarch64_G32(((0x73 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MUL_RRR_I_16_8(r0,r1,r2) do /* mul */ { 	aarch64_G32(((0x273 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MUL_RRR_I_32_4(r0,r1,r2) do /* mul */ { 	aarch64_G32(((0x275 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MUL_RRR_I_32_1(r0,r1,r2) do /* mul */ { 	aarch64_G32(((0xd8 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x1f & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MUL_RRR_I_32_2(r0,r1,r2) do /* mul */ { 	aarch64_G32(((0x75 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MUL_RRR_I_64_1(r0,r1,r2) do /* mul */ { 	aarch64_G32(((0x4d8 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x1f & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_LDRB_RRI_I_8_1(r0,r1,i0) do /* r */ { 	aarch64_G32(((0xe5 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_LDRH_RRI_I_16_1(r0,r1,i0) do /* r */ { 	aarch64_G32(((0x1e5 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_LDR_RRI_I_32_1(r0,r1,i0) do /* r */ { 	aarch64_G32(((0x2e5 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_LDP_RRI_I_32_2(r0,r1,i0) do /* r */ { 	aarch64_G32(((0xb3 & 0x3ff) << 22)|((i0 & 0x7f) << 15)|((0x0 & 0x1f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_LD1_RR_I_32_4(r0,r1) do /* r */ { 	aarch64_G32(((0x13101e & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_LDR_RRR_I_64_1(r0,r1,r2) do /* r */ { 	aarch64_G32(((0x7e3 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x36 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_LSL_RRI_I_32_1(r0,r1,i0) do /* sl */ { 	aarch64_G32(((0x14c & 0x3ff) << 22)|(((-i0 % 32 & 0x1F) & 0x3f) << 16)|(((31-i0) & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_LSL_RRR_I_32_1(r0,r1,r2) do /* sl */ { 	aarch64_G32(((0xd6 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x8 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_LSL_RRI_I_64_1(r0,r1,i0) do /* sl */ { 	aarch64_G32(((0x34d & 0x3ff) << 22)|(((-i0 % 64 & 0x1F) & 0x3f) << 16)|(((63-i0) & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_LSL_RRR_I_64_1(r0,r1,r2) do /* sl */ { 	aarch64_G32(((0x4d6 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x8 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MOV_RRR_I_8_8(r0,r1,r2) do /* mv */ { 	aarch64_G32(((0x75 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x7 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MOV_RRR_I_16_8(r0,r1,r2) do /* mv */ { 	aarch64_G32(((0x275 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x7 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MOV_RI_I_32_1(r0,i0) do /* mv */ { 	aarch64_G32(((0x294 & 0x7ff) << 21)|((i0 & 0xffff) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MOV_RR_I_32_1(r0,r1) do /* mv */ { 	aarch64_G32(((0x44000 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MOV_RR_I_32_2(r0,r1) do /* mv */ { 	aarch64_G32(((0x138207 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MOVI_RI_I_32_2(r0,i0) do /* mv */ { 	aarch64_G32(((0x1e0188 & 0x1ffffff) << 7)|((i0 & 0x3) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_DUP_RR_I_32_1(r0,r1) do /* mv */ { 	aarch64_G32(((0x178101 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_DUP_RR_I_32_2(r0,r1) do /* mv */ { 	aarch64_G32(((0x38101 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MOV_RR_I_64_1(r0,r1) do /* mv */ { 	aarch64_G32(((0x244000 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_MOV_RI_I_64_1(r0,i0) do /* mv */ { 	aarch64_G32(((0x694 & 0x7ff) << 21)|((i0 & 0xffff) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_DUP_RR_I_64_2(r0,r1) do /* mv */ { 	aarch64_G32(((0x138201 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_DUP_RR_I_64_1(r0,r1) do /* mv */ { 	aarch64_G32(((0x178201 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRR_I_8_8(r0,r1,r2) do /* sub */ { 	aarch64_G32(((0x171 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRR_I_8_16(r0,r1,r2) do /* sub */ { 	aarch64_G32(((0x371 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRR_I_16_8(r0,r1,r2) do /* sub */ { 	aarch64_G32(((0x373 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRR_I_16_4(r0,r1,r2) do /* sub */ { 	aarch64_G32(((0x173 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRR_I_32_1(r0,r1,r2) do /* sub */ { 	aarch64_G32(((0x258 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x0 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRI_I_32_1(r0,r1,i0) do /* sub */ { 	aarch64_G32(((0x144 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRR_I_32_2(r0,r1,r2) do /* sub */ { 	aarch64_G32(((0x175 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRR_I_32_4(r0,r1,r2) do /* sub */ { 	aarch64_G32(((0x375 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRR_I_64_2(r0,r1,r2) do /* sub */ { 	aarch64_G32(((0x377 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRI_I_64_1(r0,r1,i0) do /* sub */ { 	aarch64_G32(((0x344 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SUB_RRR_I_64_1(r0,r1,r2) do /* sub */ { 	aarch64_G32(((0x658 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x0 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_ADD_RRR_I_8_8(r0,r1,r2) do /* add */ { 	aarch64_G32(((0x71 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_ADD_RRR_I_8_16(r0,r1,r2) do /* add */ { 	aarch64_G32(((0x271 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_ADD_RRR_I_16_4(r0,r1,r2) do /* add */ { 	aarch64_G32(((0x73 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_ADD_RRR_I_16_8(r0,r1,r2) do /* add */ { 	aarch64_G32(((0x273 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_ADD_RRR_I_32_2(r0,r1,r2) do /* add */ { 	aarch64_G32(((0x75 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_ADD_RRR_I_32_4(r0,r1,r2) do /* add */ { 	aarch64_G32(((0x275 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_ADD_RRR_I_64_2(r0,r1,r2) do /* add */ { 	aarch64_G32(((0x277 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_ADD_RRR_I_64_1(r0,r1,r2) do /* add */ { 	aarch64_G32(((0x458 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x0 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_ADD_RRI_I_64_1(r0,r1,i0) do /* add */ { 	aarch64_G32(((0x244 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_FDIV_RRR_I_16_8(r0,r1,r2) do /* div */ { 	aarch64_G32(((0x372 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0xf & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_FDIV_RRR_I_16_4(r0,r1,r2) do /* div */ { 	aarch64_G32(((0x172 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0xf & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SDIV_RRR_I_32_1(r0,r1,r2) do /* div */ { 	aarch64_G32(((0xd6 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x3 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_FDIV_RRR_I_32_2(r0,r1,r2) do /* div */ { 	aarch64_G32(((0x171 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x3f & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_FDIV_RRR_I_32_4(r0,r1,r2) do /* div */ { 	aarch64_G32(((0x371 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x3f & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_FDIV_RRR_I_64_2(r0,r1,r2) do /* div */ { 	aarch64_G32(((0x373 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x3f & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);
#define A64_SDIV_RRR_I_64_1(r0,r1,r2) do /* div */ { 	aarch64_G32(((0x4d6 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x3 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0)); } while(0);

// Usefull macro instruction to simplify instruction selector code
#define isInt64_1(P)  ((P.arith == 'i') && (P.wLen <= 64) && (P.vLen == 1))
#define isInt32_1(P)  ((P.arith == 'i') && (P.wLen <= 32) && (P.vLen == 1))
#define isInt0(P)     ((P.arith == 'i') && (P.ValOrReg == VALUE) && (0 == P.valueImm))
#define isInt1(P)     ((P.arith == 'i') && (P.ValOrReg == VALUE) && (1 == P.valueImm))
#define isValue(P)    ((P.arith == 'i') && (P.ValOrReg == VALUE))
#define isReg32(P, X) ((P.arith == 'i') && (P.ValOrReg == REGISTER) && (X == P.regNro))
#define isRRR(P0, P1, P2) (P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
#define isRRV(P0, P1, P2) (P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
#define immValueZero (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(0)}
h2_sValue_t aarch64_genRET_0();
h2_sValue_t aarch64_genW_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genMV_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genADD_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genDIV_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genSUB_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genMUL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genR_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genSL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genRET_0()
{
// No generic optimisation for RET

// No specific optimisation for RET/aarch64

A64_RET__I_64_1();
	
}
h2_sValue_t aarch64_genW_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for W instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for W

/* -*- c -*- */

/* if (isInt32_1(P0) && isInt0(P1)  && isInt0(P2) ) */
/*   {  */
/*     #ifdef H2_DEBUG_INSN */
/*     // Store const 0 in memory (alias store, r31 interpreted as 0) */
/*     printf ("Store 0 (aarch64)\\n"); */
/*     #endif */
/*     A64_STR_RRI_I_32_1(P0.regNro, 31, 0); */
/*     return P0; */
/*   } */

if (isValue(P1))
  { // Store constant (Should use RRI variant)
	h2_sValue_t PTMP = {REGISTER, P1.arith, P1.vLen, P1.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RI W (aarch64)\\n");
    #endif
	// MV const in tmp register
	P1 = aarch64_genMV_3(PTMP,  P1, immValueZero);
	// No return continue instruction selection
  }

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_ST1_RR_I_32_4(P0.regNro, P1.regNro);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 8) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_STRB_RRI_I_8_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 16) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_STRH_RRI_I_16_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_ST1_RRI_I_32_4(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_STR_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_STR_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_STR_RRI_I_32_2(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 64) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_STR_RRI_I_64_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 64) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_STR_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P1;
    }
	printf ("Warning, W instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genMV_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for MV instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for MV

// No specific optimisation for MV/aarch64

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
	A64_MOV_RI_I_32_1(P0.regNro, P1.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_MOV_RR_I_32_1(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_MOV_RR_I_32_2(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
	A64_MOVI_RI_I_32_2(P0.regNro, P1.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_DUP_RR_I_32_1(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_DUP_RR_I_32_2(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_MOV_RR_I_64_1(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
	A64_MOV_RI_I_64_1(P0.regNro, P1.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_DUP_RR_I_64_2(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_DUP_RR_I_64_1(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MOV_RRR_I_8_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MOV_RRR_I_16_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, MV instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genADD_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for ADD instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
/* -*- c -*- */
if (isInt0 (P2))
  { // P0 = P1 + 0
    #ifdef H2_DEBUG_INSN
	printf ("Optim add for 0 (generic) return reg %d\n", P1.regNro);
    #endif
	return P1;
  }
if (isInt0 (P1))
  { // P0 = 0 + P2
    #ifdef H2_DEBUG_INSN
    printf ("Optim add for 0  (generic) return reg %d\n", P2.regNro);
    #endif
    return P2;
  }

// No specific optimisation for ADD/aarch64

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_8_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 16) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_8_16(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_16_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_16_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_32_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_32_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_64_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_ADD_RRI_I_64_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }
	printf ("Warning, ADD instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genDIV_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for DIV instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for DIV

/* -*- c -*- */
if  ((P2.ValOrReg == VALUE) && (P2.arith == 'i'))
{
	h2_sValue_t PTMP = {REGISTER, P2.arith, P2.vLen, P2.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RRI div (aarch64)\\n");
    #endif
	P2 = aarch64_genMV_3(PTMP,  P2, immValueZero);
}

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_FDIV_RRR_I_16_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_FDIV_RRR_I_16_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SDIV_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_FDIV_RRR_I_32_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_FDIV_RRR_I_32_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_FDIV_RRR_I_64_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SDIV_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, DIV instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genSUB_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for SUB instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for SUB

// No specific optimisation for SUB/aarch64

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_8_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 16) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_8_16(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_16_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_16_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_SUB_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_32_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_32_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_64_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_SUB_RRI_I_64_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, SUB instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genMUL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for MUL instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
/* -*- c -*- */
  if (isInt0(P2) || isInt0(P1))
   {    // X * 0 = 0 Avoid 1 operation mul & 1 mv
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *0 P2 (generic)\n");
        #endif
        return immValueZero;
    }
  if (isInt1(P2))
    { // X * 1 = X propagate register result
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *1 P2 (generic)\n");
        #endif
        return P1;
    }
  if (isInt1(P1))
    { // 1 * X = X propagate register result
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *1 P1 (generic)\n");
        #endif
        return P2;
    }
/* -*- c -*- */
if  ((P1.ValOrReg == VALUE) && (P2.ValOrReg == REGISTER))
    { // Transform RIR in RRI : P1 & P2 permutation
       h2_sValue_t PTMP = P2;
       P2 = P1;
       P1 = PTMP; 
    }
if  ((P2.ValOrReg == VALUE) && (P2.arith == 'i') && ((P2.valueImm != 0) && !(P2.valueImm & (P2.valueImm - 1))))
  { // X * NPowerOf2 = X << N (immediate shift left)
	int shiftValue = h2_log2(P2.valueImm);
    #ifdef H2_DEBUG_INSN
      printf ("Optim for * %d (power of 2) -> sl %d (aarch64)\n", P2.valueImm, shiftValue);
    #endif
	// Instruction shift left immediat
	P2.valueImm = shiftValue;
	return aarch64_genSL_3(P0, P1, P2);
  }
if  ((P2.ValOrReg == VALUE) && (P2.arith == 'i'))
{
	h2_sValue_t PTMP = {REGISTER, P2.arith, P2.vLen, P2.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RRI mul (aarch64)\n");
    #endif
	P2 = aarch64_genMV_3(PTMP,  P2, immValueZero);
	// No return continue instruction selection
}

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_8_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 16) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_8_16(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_16_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_16_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_32_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_32_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, MUL instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genR_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for R instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for R

// No specific optimisation for R/aarch64

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_LD1_RR_I_32_4(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LDRB_RRI_I_8_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LDRH_RRI_I_16_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LDR_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LDP_RRI_I_32_2(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_LDR_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, R instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genSL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for SL instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for SL

// No specific optimisation for SL/aarch64

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LSL_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_LSL_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LSL_RRI_I_64_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_LSL_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, SL instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}

/* End Header autogenerated part */
// -*- c -*-
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include "ReadPgmImage.h"

typedef  int (*pifc)(int[],int,int,int,int);


unsigned char clamp(int value) {
  if (value < 0) return 0;
  if (value > 255) return 255;
  return (unsigned char)value;
}



pifc genKernel3x3(pifc ptr,int** Filter,int coeff)
{
  //printf("%i %i %i\n%i %i %i\n%i %i %i\ncoeff is : %i\n",Filter[0][0],Filter[0][1],Filter[0][2],Filter[1][0],Filter[1][1],Filter[1][2],Filter[2][0],Filter[2][1],Filter[2][2],coeff);
	/* Code Generation of 17 instructions */
	/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t In = {REGISTER, 'i', 1, 32, 0, 0};
	h2_sValue_t line = {REGISTER, 'i', 1, 32, 1, 0};
	h2_sValue_t column = {REGISTER, 'i', 1, 32, 2, 0};
	h2_sValue_t Inwidth = {REGISTER, 'i', 1, 32, 3, 0};
	h2_sValue_t Inheight = {REGISTER, 'i', 1, 32, 4, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 1, 32, 0, 0};
	h2_sValue_t sum = {REGISTER, 'i', 1, 32, 9, 0};
	h2_sValue_t ni = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t nj1 = {REGISTER, 'i', 1, 32, 11, 0};
	h2_sValue_t nj0 = {REGISTER, 'i', 1, 32, 12, 0};
	h2_sValue_t njm1 = {REGISTER, 'i', 1, 32, 13, 0};
	h2_sValue_t tmp0000 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0001 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0002 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0003 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0004 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0005 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0006 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0007 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0008 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0009 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0010 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0011 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0012 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0013 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0014 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0015 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0016 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0017 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0018 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0019 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0020 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0021 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0022 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0023 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0024 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0025 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0026 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0027 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0028 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0029 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0030 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0031 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0032 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0033 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0034 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0035 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0036 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0037 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0038 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0039 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0040 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0041 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0042 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0043 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0044 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0045 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0046 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0047 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0048 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0049 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0050 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0051 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0052 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0053 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0054 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0055 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0056 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0057 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0058 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0059 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0060 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0061 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0062 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0063 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0064 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0065 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0066 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0067 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0068 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0069 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0070 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0071 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0072 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0073 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0074 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0075 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0076 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0077 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0078 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0079 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0080 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0081 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0082 = {REGISTER, 'i', 1, 32, -1, 0};

	/* Label  table :*/
/* No label table to avoid C warning for empty table ... */
	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = true;
	h2_start_codeGen = h2_getticks();
	h2_initRegisterMasks(0xFFFF3F1F, 0, 0, 0);
	h2_resetRegisterMasks();
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask initialization\n");
	#endif // H2_DEBUG_REGISTER
	tmp0000 = aarch64_genADD_3(tmp0000, column, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(1)});
	nj1 = aarch64_genMV_3(nj1, tmp0000, immValueZero);
	h2_freeReg(tmp0000.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	nj0 = aarch64_genMV_3(nj0, column, immValueZero);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0003 = aarch64_genSUB_3(tmp0003, column, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(1)});
	njm1 = aarch64_genMV_3(njm1, tmp0003, immValueZero);
	h2_freeReg(tmp0003.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0005 = aarch64_genSUB_3(tmp0005, line, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(1)});
	ni = aarch64_genMV_3(ni, tmp0005, immValueZero);
	h2_freeReg(tmp0005.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0007 = aarch64_genMUL_3(tmp0007, ni, Inwidth);
	tmp0008 = aarch64_genADD_3(tmp0008, tmp0007, njm1);
	h2_freeReg(tmp0007.regNro);
	tmp0009 = aarch64_genMUL_3(tmp0009, tmp0008, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0008.regNro);
	tmp0010 = aarch64_genADD_3(tmp0010, In, tmp0009);
	h2_freeReg(tmp0009.regNro);
	tmp0011 = aarch64_genR_3(tmp0011, tmp0010, immValueZero);
	tmp0012 = aarch64_genMUL_3(tmp0012, tmp0011, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[0][0]))});
	h2_freeReg(tmp0011.regNro);
	sum = aarch64_genMV_3(sum, tmp0012, immValueZero);
	h2_freeReg(tmp0012.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0014 = aarch64_genMUL_3(tmp0014, ni, Inwidth);
	tmp0015 = aarch64_genADD_3(tmp0015, tmp0014, nj0);
	h2_freeReg(tmp0014.regNro);
	tmp0016 = aarch64_genMUL_3(tmp0016, tmp0015, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0015.regNro);
	tmp0017 = aarch64_genADD_3(tmp0017, In, tmp0016);
	h2_freeReg(tmp0016.regNro);
	tmp0018 = aarch64_genR_3(tmp0018, tmp0017, immValueZero);
	tmp0019 = aarch64_genMUL_3(tmp0019, tmp0018, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[0][1]))});
	h2_freeReg(tmp0018.regNro);
	tmp0020 = aarch64_genADD_3(tmp0020, sum, tmp0019);
	h2_freeReg(tmp0019.regNro);
	sum = aarch64_genMV_3(sum, tmp0020, immValueZero);
	h2_freeReg(tmp0020.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0022 = aarch64_genMUL_3(tmp0022, ni, Inwidth);
	tmp0023 = aarch64_genADD_3(tmp0023, tmp0022, nj1);
	h2_freeReg(tmp0022.regNro);
	tmp0024 = aarch64_genMUL_3(tmp0024, tmp0023, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0023.regNro);
	tmp0025 = aarch64_genADD_3(tmp0025, In, tmp0024);
	h2_freeReg(tmp0024.regNro);
	tmp0026 = aarch64_genR_3(tmp0026, tmp0025, immValueZero);
	tmp0027 = aarch64_genMUL_3(tmp0027, tmp0026, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[0][2]))});
	h2_freeReg(tmp0026.regNro);
	tmp0028 = aarch64_genADD_3(tmp0028, sum, tmp0027);
	h2_freeReg(tmp0027.regNro);
	sum = aarch64_genMV_3(sum, tmp0028, immValueZero);
	h2_freeReg(tmp0028.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	ni = aarch64_genMV_3(ni, line, immValueZero);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0031 = aarch64_genMUL_3(tmp0031, ni, Inwidth);
	tmp0032 = aarch64_genADD_3(tmp0032, tmp0031, njm1);
	h2_freeReg(tmp0031.regNro);
	tmp0033 = aarch64_genMUL_3(tmp0033, tmp0032, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0032.regNro);
	tmp0034 = aarch64_genADD_3(tmp0034, In, tmp0033);
	h2_freeReg(tmp0033.regNro);
	tmp0035 = aarch64_genR_3(tmp0035, tmp0034, immValueZero);
	tmp0036 = aarch64_genMUL_3(tmp0036, tmp0035, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[1][0]))});
	h2_freeReg(tmp0035.regNro);
	tmp0037 = aarch64_genADD_3(tmp0037, sum, tmp0036);
	h2_freeReg(tmp0036.regNro);
	sum = aarch64_genMV_3(sum, tmp0037, immValueZero);
	h2_freeReg(tmp0037.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0039 = aarch64_genMUL_3(tmp0039, ni, Inwidth);
	tmp0040 = aarch64_genADD_3(tmp0040, tmp0039, nj0);
	h2_freeReg(tmp0039.regNro);
	tmp0041 = aarch64_genMUL_3(tmp0041, tmp0040, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0040.regNro);
	tmp0042 = aarch64_genADD_3(tmp0042, In, tmp0041);
	h2_freeReg(tmp0041.regNro);
	tmp0043 = aarch64_genR_3(tmp0043, tmp0042, immValueZero);
	tmp0044 = aarch64_genMUL_3(tmp0044, tmp0043, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[1][1]))});
	h2_freeReg(tmp0043.regNro);
	tmp0045 = aarch64_genADD_3(tmp0045, sum, tmp0044);
	h2_freeReg(tmp0044.regNro);
	sum = aarch64_genMV_3(sum, tmp0045, immValueZero);
	h2_freeReg(tmp0045.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0047 = aarch64_genMUL_3(tmp0047, ni, Inwidth);
	tmp0048 = aarch64_genADD_3(tmp0048, tmp0047, nj1);
	h2_freeReg(tmp0047.regNro);
	tmp0049 = aarch64_genMUL_3(tmp0049, tmp0048, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0048.regNro);
	tmp0050 = aarch64_genADD_3(tmp0050, In, tmp0049);
	h2_freeReg(tmp0049.regNro);
	tmp0051 = aarch64_genR_3(tmp0051, tmp0050, immValueZero);
	tmp0052 = aarch64_genMUL_3(tmp0052, tmp0051, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[1][2]))});
	h2_freeReg(tmp0051.regNro);
	tmp0053 = aarch64_genADD_3(tmp0053, sum, tmp0052);
	h2_freeReg(tmp0052.regNro);
	sum = aarch64_genMV_3(sum, tmp0053, immValueZero);
	h2_freeReg(tmp0053.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0055 = aarch64_genADD_3(tmp0055, line, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(1)});
	ni = aarch64_genMV_3(ni, tmp0055, immValueZero);
	h2_freeReg(tmp0055.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0057 = aarch64_genMUL_3(tmp0057, ni, Inwidth);
	tmp0058 = aarch64_genADD_3(tmp0058, tmp0057, njm1);
	h2_freeReg(tmp0057.regNro);
	tmp0059 = aarch64_genMUL_3(tmp0059, tmp0058, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0058.regNro);
	tmp0060 = aarch64_genADD_3(tmp0060, In, tmp0059);
	h2_freeReg(tmp0059.regNro);
	tmp0061 = aarch64_genR_3(tmp0061, tmp0060, immValueZero);
	tmp0062 = aarch64_genMUL_3(tmp0062, tmp0061, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[2][0]))});
	h2_freeReg(tmp0061.regNro);
	tmp0063 = aarch64_genADD_3(tmp0063, sum, tmp0062);
	h2_freeReg(tmp0062.regNro);
	sum = aarch64_genMV_3(sum, tmp0063, immValueZero);
	h2_freeReg(tmp0063.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0065 = aarch64_genMUL_3(tmp0065, ni, Inwidth);
	tmp0066 = aarch64_genADD_3(tmp0066, tmp0065, nj0);
	h2_freeReg(tmp0065.regNro);
	tmp0067 = aarch64_genMUL_3(tmp0067, tmp0066, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0066.regNro);
	tmp0068 = aarch64_genADD_3(tmp0068, In, tmp0067);
	h2_freeReg(tmp0067.regNro);
	tmp0069 = aarch64_genR_3(tmp0069, tmp0068, immValueZero);
	tmp0070 = aarch64_genMUL_3(tmp0070, tmp0069, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[2][1]))});
	h2_freeReg(tmp0069.regNro);
	tmp0071 = aarch64_genADD_3(tmp0071, sum, tmp0070);
	h2_freeReg(tmp0070.regNro);
	sum = aarch64_genMV_3(sum, tmp0071, immValueZero);
	h2_freeReg(tmp0071.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0073 = aarch64_genMUL_3(tmp0073, ni, Inwidth);
	tmp0074 = aarch64_genADD_3(tmp0074, tmp0073, nj1);
	h2_freeReg(tmp0073.regNro);
	tmp0075 = aarch64_genMUL_3(tmp0075, tmp0074, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0074.regNro);
	tmp0076 = aarch64_genADD_3(tmp0076, In, tmp0075);
	h2_freeReg(tmp0075.regNro);
	tmp0077 = aarch64_genR_3(tmp0077, tmp0076, immValueZero);
	tmp0078 = aarch64_genMUL_3(tmp0078, tmp0077, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[2][2]))});
	h2_freeReg(tmp0077.regNro);
	tmp0079 = aarch64_genADD_3(tmp0079, sum, tmp0078);
	h2_freeReg(tmp0078.regNro);
	sum = aarch64_genMV_3(sum, tmp0079, immValueZero);
	h2_freeReg(tmp0079.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0081 = aarch64_genDIV_3(tmp0081, sum, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((coeff))});
	h2_outputVarName = aarch64_genMV_3(h2_outputVarName, tmp0081, immValueZero);
	h2_freeReg(tmp0081.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	aarch64_genRET_0();
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	h2_end_codeGen = h2_getticks();
	h2_iflush(ptr, h2_asm_pc);

  return ptr;
}


pifc genKernel5x5(pifc ptr,int** Filter,int coeff)
{
  //printf("%i %i %i\n%i %i %i\n%i %i %i\ncoeff is : %i\n",Filter[0][0],Filter[0][1],Filter[0][2],Filter[1][0],Filter[1][1],Filter[1][2],Filter[2][0],Filter[2][1],Filter[2][2],coeff);
	/* Code Generation of 36 instructions */
	/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t In = {REGISTER, 'i', 1, 32, 0, 0};
	h2_sValue_t line = {REGISTER, 'i', 1, 32, 1, 0};
	h2_sValue_t column = {REGISTER, 'i', 1, 32, 2, 0};
	h2_sValue_t Inwidth = {REGISTER, 'i', 1, 32, 3, 0};
	h2_sValue_t Inheight = {REGISTER, 'i', 1, 32, 4, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 1, 32, 0, 0};
	h2_sValue_t sum = {REGISTER, 'i', 1, 32, 9, 0};
	h2_sValue_t ni = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t njm2 = {REGISTER, 'i', 1, 32, 11, 0};
	h2_sValue_t njm1 = {REGISTER, 'i', 1, 32, 12, 0};
	h2_sValue_t nj1 = {REGISTER, 'i', 1, 32, 13, 0};
	h2_sValue_t nj2 = {REGISTER, 'i', 1, 32, 14, 0};
	h2_sValue_t tmp0000 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0001 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0002 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0003 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0004 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0005 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0006 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0007 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0008 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0009 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0010 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0011 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0012 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0013 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0014 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0015 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0016 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0017 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0018 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0019 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0020 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0021 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0022 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0023 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0024 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0025 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0026 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0027 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0028 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0029 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0030 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0031 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0032 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0033 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0034 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0035 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0036 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0037 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0038 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0039 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0040 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0041 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0042 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0043 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0044 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0045 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0046 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0047 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0048 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0049 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0050 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0051 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0052 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0053 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0054 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0055 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0056 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0057 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0058 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0059 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0060 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0061 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0062 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0063 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0064 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0065 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0066 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0067 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0068 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0069 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0070 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0071 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0072 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0073 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0074 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0075 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0076 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0077 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0078 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0079 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0080 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0081 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0082 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0083 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0084 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0085 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0086 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0087 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0088 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0089 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0090 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0091 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0092 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0093 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0094 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0095 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0096 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0097 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0098 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0099 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0100 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0101 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0102 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0103 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0104 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0105 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0106 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0107 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0108 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0109 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0110 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0111 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0112 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0113 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0114 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0115 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0116 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0117 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0118 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0119 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0120 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0121 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0122 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0123 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0124 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0125 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0126 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0127 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0128 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0129 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0130 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0131 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0132 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0133 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0134 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0135 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0136 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0137 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0138 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0139 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0140 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0141 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0142 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0143 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0144 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0145 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0146 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0147 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0148 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0149 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0150 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0151 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0152 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0153 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0154 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0155 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0156 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0157 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0158 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0159 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0160 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0161 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0162 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0163 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0164 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0165 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0166 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0167 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0168 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0169 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0170 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0171 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0172 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0173 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0174 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0175 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0176 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0177 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0178 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0179 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0180 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0181 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0182 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0183 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0184 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0185 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0186 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0187 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0188 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0189 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0190 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0191 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0192 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0193 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0194 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0195 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0196 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0197 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0198 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0199 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0200 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0201 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0202 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0203 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0204 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0205 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0206 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0207 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0208 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0209 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0210 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0211 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0212 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0213 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0214 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0215 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0216 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0217 = {REGISTER, 'i', 1, 32, -1, 0};

	/* Label  table :*/
/* No label table to avoid C warning for empty table ... */
	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = true;
	h2_start_codeGen = h2_getticks();
	h2_initRegisterMasks(0xFFFF7F1F, 0, 0, 0);
	h2_resetRegisterMasks();
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask initialization\n");
	#endif // H2_DEBUG_REGISTER
	tmp0000 = aarch64_genSUB_3(tmp0000, column, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(2)});
	njm2 = aarch64_genMV_3(njm2, tmp0000, immValueZero);
	h2_freeReg(tmp0000.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0002 = aarch64_genSUB_3(tmp0002, column, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(1)});
	njm1 = aarch64_genMV_3(njm1, tmp0002, immValueZero);
	h2_freeReg(tmp0002.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0004 = aarch64_genADD_3(tmp0004, column, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(1)});
	nj1 = aarch64_genMV_3(nj1, tmp0004, immValueZero);
	h2_freeReg(tmp0004.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0006 = aarch64_genADD_3(tmp0006, column, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(2)});
	nj2 = aarch64_genMV_3(nj2, tmp0006, immValueZero);
	h2_freeReg(tmp0006.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0008 = aarch64_genSUB_3(tmp0008, line, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(2)});
	ni = aarch64_genMV_3(ni, tmp0008, immValueZero);
	h2_freeReg(tmp0008.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0010 = aarch64_genMUL_3(tmp0010, ni, Inwidth);
	tmp0011 = aarch64_genADD_3(tmp0011, tmp0010, njm2);
	h2_freeReg(tmp0010.regNro);
	tmp0012 = aarch64_genMUL_3(tmp0012, tmp0011, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0011.regNro);
	tmp0013 = aarch64_genADD_3(tmp0013, In, tmp0012);
	h2_freeReg(tmp0012.regNro);
	tmp0014 = aarch64_genR_3(tmp0014, tmp0013, immValueZero);
	tmp0015 = aarch64_genMUL_3(tmp0015, tmp0014, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[0][0]))});
	h2_freeReg(tmp0014.regNro);
	sum = aarch64_genMV_3(sum, tmp0015, immValueZero);
	h2_freeReg(tmp0015.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0017 = aarch64_genMUL_3(tmp0017, ni, Inwidth);
	tmp0018 = aarch64_genADD_3(tmp0018, tmp0017, njm1);
	h2_freeReg(tmp0017.regNro);
	tmp0019 = aarch64_genMUL_3(tmp0019, tmp0018, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0018.regNro);
	tmp0020 = aarch64_genADD_3(tmp0020, In, tmp0019);
	h2_freeReg(tmp0019.regNro);
	tmp0021 = aarch64_genR_3(tmp0021, tmp0020, immValueZero);
	tmp0022 = aarch64_genMUL_3(tmp0022, tmp0021, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[0][1]))});
	h2_freeReg(tmp0021.regNro);
	tmp0023 = aarch64_genADD_3(tmp0023, sum, tmp0022);
	h2_freeReg(tmp0022.regNro);
	sum = aarch64_genMV_3(sum, tmp0023, immValueZero);
	h2_freeReg(tmp0023.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0025 = aarch64_genMUL_3(tmp0025, ni, Inwidth);
	tmp0026 = aarch64_genADD_3(tmp0026, tmp0025, column);
	h2_freeReg(tmp0025.regNro);
	tmp0027 = aarch64_genMUL_3(tmp0027, tmp0026, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0026.regNro);
	tmp0028 = aarch64_genADD_3(tmp0028, In, tmp0027);
	h2_freeReg(tmp0027.regNro);
	tmp0029 = aarch64_genR_3(tmp0029, tmp0028, immValueZero);
	tmp0030 = aarch64_genMUL_3(tmp0030, tmp0029, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[0][2]))});
	h2_freeReg(tmp0029.regNro);
	tmp0031 = aarch64_genADD_3(tmp0031, sum, tmp0030);
	h2_freeReg(tmp0030.regNro);
	sum = aarch64_genMV_3(sum, tmp0031, immValueZero);
	h2_freeReg(tmp0031.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0033 = aarch64_genMUL_3(tmp0033, ni, Inwidth);
	tmp0034 = aarch64_genADD_3(tmp0034, tmp0033, nj1);
	h2_freeReg(tmp0033.regNro);
	tmp0035 = aarch64_genMUL_3(tmp0035, tmp0034, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0034.regNro);
	tmp0036 = aarch64_genADD_3(tmp0036, In, tmp0035);
	h2_freeReg(tmp0035.regNro);
	tmp0037 = aarch64_genR_3(tmp0037, tmp0036, immValueZero);
	tmp0038 = aarch64_genMUL_3(tmp0038, tmp0037, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[0][3]))});
	h2_freeReg(tmp0037.regNro);
	tmp0039 = aarch64_genADD_3(tmp0039, sum, tmp0038);
	h2_freeReg(tmp0038.regNro);
	sum = aarch64_genMV_3(sum, tmp0039, immValueZero);
	h2_freeReg(tmp0039.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0041 = aarch64_genMUL_3(tmp0041, ni, Inwidth);
	tmp0042 = aarch64_genADD_3(tmp0042, tmp0041, nj1);
	h2_freeReg(tmp0041.regNro);
	tmp0043 = aarch64_genMUL_3(tmp0043, tmp0042, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0042.regNro);
	tmp0044 = aarch64_genADD_3(tmp0044, In, tmp0043);
	h2_freeReg(tmp0043.regNro);
	tmp0045 = aarch64_genR_3(tmp0045, tmp0044, immValueZero);
	tmp0046 = aarch64_genMUL_3(tmp0046, tmp0045, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[0][4]))});
	h2_freeReg(tmp0045.regNro);
	tmp0047 = aarch64_genADD_3(tmp0047, sum, tmp0046);
	h2_freeReg(tmp0046.regNro);
	sum = aarch64_genMV_3(sum, tmp0047, immValueZero);
	h2_freeReg(tmp0047.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0049 = aarch64_genSUB_3(tmp0049, line, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(1)});
	ni = aarch64_genMV_3(ni, tmp0049, immValueZero);
	h2_freeReg(tmp0049.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0051 = aarch64_genMUL_3(tmp0051, ni, Inwidth);
	tmp0052 = aarch64_genADD_3(tmp0052, tmp0051, njm2);
	h2_freeReg(tmp0051.regNro);
	tmp0053 = aarch64_genMUL_3(tmp0053, tmp0052, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0052.regNro);
	tmp0054 = aarch64_genADD_3(tmp0054, In, tmp0053);
	h2_freeReg(tmp0053.regNro);
	tmp0055 = aarch64_genR_3(tmp0055, tmp0054, immValueZero);
	tmp0056 = aarch64_genMUL_3(tmp0056, tmp0055, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[1][0]))});
	h2_freeReg(tmp0055.regNro);
	tmp0057 = aarch64_genADD_3(tmp0057, sum, tmp0056);
	h2_freeReg(tmp0056.regNro);
	sum = aarch64_genMV_3(sum, tmp0057, immValueZero);
	h2_freeReg(tmp0057.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0059 = aarch64_genMUL_3(tmp0059, ni, Inwidth);
	tmp0060 = aarch64_genADD_3(tmp0060, tmp0059, njm1);
	h2_freeReg(tmp0059.regNro);
	tmp0061 = aarch64_genMUL_3(tmp0061, tmp0060, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0060.regNro);
	tmp0062 = aarch64_genADD_3(tmp0062, In, tmp0061);
	h2_freeReg(tmp0061.regNro);
	tmp0063 = aarch64_genR_3(tmp0063, tmp0062, immValueZero);
	tmp0064 = aarch64_genMUL_3(tmp0064, tmp0063, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[1][1]))});
	h2_freeReg(tmp0063.regNro);
	tmp0065 = aarch64_genADD_3(tmp0065, sum, tmp0064);
	h2_freeReg(tmp0064.regNro);
	sum = aarch64_genMV_3(sum, tmp0065, immValueZero);
	h2_freeReg(tmp0065.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0067 = aarch64_genMUL_3(tmp0067, ni, Inwidth);
	tmp0068 = aarch64_genADD_3(tmp0068, tmp0067, column);
	h2_freeReg(tmp0067.regNro);
	tmp0069 = aarch64_genMUL_3(tmp0069, tmp0068, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0068.regNro);
	tmp0070 = aarch64_genADD_3(tmp0070, In, tmp0069);
	h2_freeReg(tmp0069.regNro);
	tmp0071 = aarch64_genR_3(tmp0071, tmp0070, immValueZero);
	tmp0072 = aarch64_genMUL_3(tmp0072, tmp0071, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[1][2]))});
	h2_freeReg(tmp0071.regNro);
	tmp0073 = aarch64_genADD_3(tmp0073, sum, tmp0072);
	h2_freeReg(tmp0072.regNro);
	sum = aarch64_genMV_3(sum, tmp0073, immValueZero);
	h2_freeReg(tmp0073.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0075 = aarch64_genMUL_3(tmp0075, ni, Inwidth);
	tmp0076 = aarch64_genADD_3(tmp0076, tmp0075, nj1);
	h2_freeReg(tmp0075.regNro);
	tmp0077 = aarch64_genMUL_3(tmp0077, tmp0076, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0076.regNro);
	tmp0078 = aarch64_genADD_3(tmp0078, In, tmp0077);
	h2_freeReg(tmp0077.regNro);
	tmp0079 = aarch64_genR_3(tmp0079, tmp0078, immValueZero);
	tmp0080 = aarch64_genMUL_3(tmp0080, tmp0079, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[1][3]))});
	h2_freeReg(tmp0079.regNro);
	tmp0081 = aarch64_genADD_3(tmp0081, sum, tmp0080);
	h2_freeReg(tmp0080.regNro);
	sum = aarch64_genMV_3(sum, tmp0081, immValueZero);
	h2_freeReg(tmp0081.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0083 = aarch64_genMUL_3(tmp0083, ni, Inwidth);
	tmp0084 = aarch64_genADD_3(tmp0084, tmp0083, nj2);
	h2_freeReg(tmp0083.regNro);
	tmp0085 = aarch64_genMUL_3(tmp0085, tmp0084, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0084.regNro);
	tmp0086 = aarch64_genADD_3(tmp0086, In, tmp0085);
	h2_freeReg(tmp0085.regNro);
	tmp0087 = aarch64_genR_3(tmp0087, tmp0086, immValueZero);
	tmp0088 = aarch64_genMUL_3(tmp0088, tmp0087, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[1][4]))});
	h2_freeReg(tmp0087.regNro);
	tmp0089 = aarch64_genADD_3(tmp0089, sum, tmp0088);
	h2_freeReg(tmp0088.regNro);
	sum = aarch64_genMV_3(sum, tmp0089, immValueZero);
	h2_freeReg(tmp0089.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	ni = aarch64_genMV_3(ni, line, immValueZero);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0092 = aarch64_genMUL_3(tmp0092, ni, Inwidth);
	tmp0093 = aarch64_genADD_3(tmp0093, tmp0092, njm2);
	h2_freeReg(tmp0092.regNro);
	tmp0094 = aarch64_genMUL_3(tmp0094, tmp0093, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0093.regNro);
	tmp0095 = aarch64_genADD_3(tmp0095, In, tmp0094);
	h2_freeReg(tmp0094.regNro);
	tmp0096 = aarch64_genR_3(tmp0096, tmp0095, immValueZero);
	tmp0097 = aarch64_genMUL_3(tmp0097, tmp0096, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[2][0]))});
	h2_freeReg(tmp0096.regNro);
	tmp0098 = aarch64_genADD_3(tmp0098, sum, tmp0097);
	h2_freeReg(tmp0097.regNro);
	sum = aarch64_genMV_3(sum, tmp0098, immValueZero);
	h2_freeReg(tmp0098.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0100 = aarch64_genMUL_3(tmp0100, ni, Inwidth);
	tmp0101 = aarch64_genADD_3(tmp0101, tmp0100, njm1);
	h2_freeReg(tmp0100.regNro);
	tmp0102 = aarch64_genMUL_3(tmp0102, tmp0101, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0101.regNro);
	tmp0103 = aarch64_genADD_3(tmp0103, In, tmp0102);
	h2_freeReg(tmp0102.regNro);
	tmp0104 = aarch64_genR_3(tmp0104, tmp0103, immValueZero);
	tmp0105 = aarch64_genMUL_3(tmp0105, tmp0104, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[2][1]))});
	h2_freeReg(tmp0104.regNro);
	tmp0106 = aarch64_genADD_3(tmp0106, sum, tmp0105);
	h2_freeReg(tmp0105.regNro);
	sum = aarch64_genMV_3(sum, tmp0106, immValueZero);
	h2_freeReg(tmp0106.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0108 = aarch64_genMUL_3(tmp0108, ni, Inwidth);
	tmp0109 = aarch64_genADD_3(tmp0109, tmp0108, column);
	h2_freeReg(tmp0108.regNro);
	tmp0110 = aarch64_genMUL_3(tmp0110, tmp0109, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0109.regNro);
	tmp0111 = aarch64_genADD_3(tmp0111, In, tmp0110);
	h2_freeReg(tmp0110.regNro);
	tmp0112 = aarch64_genR_3(tmp0112, tmp0111, immValueZero);
	tmp0113 = aarch64_genMUL_3(tmp0113, tmp0112, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[2][2]))});
	h2_freeReg(tmp0112.regNro);
	tmp0114 = aarch64_genADD_3(tmp0114, sum, tmp0113);
	h2_freeReg(tmp0113.regNro);
	sum = aarch64_genMV_3(sum, tmp0114, immValueZero);
	h2_freeReg(tmp0114.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0116 = aarch64_genMUL_3(tmp0116, ni, Inwidth);
	tmp0117 = aarch64_genADD_3(tmp0117, tmp0116, nj1);
	h2_freeReg(tmp0116.regNro);
	tmp0118 = aarch64_genMUL_3(tmp0118, tmp0117, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0117.regNro);
	tmp0119 = aarch64_genADD_3(tmp0119, In, tmp0118);
	h2_freeReg(tmp0118.regNro);
	tmp0120 = aarch64_genR_3(tmp0120, tmp0119, immValueZero);
	tmp0121 = aarch64_genMUL_3(tmp0121, tmp0120, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[2][3]))});
	h2_freeReg(tmp0120.regNro);
	tmp0122 = aarch64_genADD_3(tmp0122, sum, tmp0121);
	h2_freeReg(tmp0121.regNro);
	sum = aarch64_genMV_3(sum, tmp0122, immValueZero);
	h2_freeReg(tmp0122.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0124 = aarch64_genMUL_3(tmp0124, ni, Inwidth);
	tmp0125 = aarch64_genADD_3(tmp0125, tmp0124, nj2);
	h2_freeReg(tmp0124.regNro);
	tmp0126 = aarch64_genMUL_3(tmp0126, tmp0125, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0125.regNro);
	tmp0127 = aarch64_genADD_3(tmp0127, In, tmp0126);
	h2_freeReg(tmp0126.regNro);
	tmp0128 = aarch64_genR_3(tmp0128, tmp0127, immValueZero);
	tmp0129 = aarch64_genMUL_3(tmp0129, tmp0128, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[2][4]))});
	h2_freeReg(tmp0128.regNro);
	tmp0130 = aarch64_genADD_3(tmp0130, sum, tmp0129);
	h2_freeReg(tmp0129.regNro);
	sum = aarch64_genMV_3(sum, tmp0130, immValueZero);
	h2_freeReg(tmp0130.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0132 = aarch64_genADD_3(tmp0132, line, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(1)});
	ni = aarch64_genMV_3(ni, tmp0132, immValueZero);
	h2_freeReg(tmp0132.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0134 = aarch64_genMUL_3(tmp0134, ni, Inwidth);
	tmp0135 = aarch64_genADD_3(tmp0135, tmp0134, njm2);
	h2_freeReg(tmp0134.regNro);
	tmp0136 = aarch64_genMUL_3(tmp0136, tmp0135, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0135.regNro);
	tmp0137 = aarch64_genADD_3(tmp0137, In, tmp0136);
	h2_freeReg(tmp0136.regNro);
	tmp0138 = aarch64_genR_3(tmp0138, tmp0137, immValueZero);
	tmp0139 = aarch64_genMUL_3(tmp0139, tmp0138, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[3][0]))});
	h2_freeReg(tmp0138.regNro);
	tmp0140 = aarch64_genADD_3(tmp0140, sum, tmp0139);
	h2_freeReg(tmp0139.regNro);
	sum = aarch64_genMV_3(sum, tmp0140, immValueZero);
	h2_freeReg(tmp0140.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0142 = aarch64_genMUL_3(tmp0142, ni, Inwidth);
	tmp0143 = aarch64_genADD_3(tmp0143, tmp0142, njm1);
	h2_freeReg(tmp0142.regNro);
	tmp0144 = aarch64_genMUL_3(tmp0144, tmp0143, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0143.regNro);
	tmp0145 = aarch64_genADD_3(tmp0145, In, tmp0144);
	h2_freeReg(tmp0144.regNro);
	tmp0146 = aarch64_genR_3(tmp0146, tmp0145, immValueZero);
	tmp0147 = aarch64_genMUL_3(tmp0147, tmp0146, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[3][1]))});
	h2_freeReg(tmp0146.regNro);
	tmp0148 = aarch64_genADD_3(tmp0148, sum, tmp0147);
	h2_freeReg(tmp0147.regNro);
	sum = aarch64_genMV_3(sum, tmp0148, immValueZero);
	h2_freeReg(tmp0148.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0150 = aarch64_genMUL_3(tmp0150, ni, Inwidth);
	tmp0151 = aarch64_genADD_3(tmp0151, tmp0150, column);
	h2_freeReg(tmp0150.regNro);
	tmp0152 = aarch64_genMUL_3(tmp0152, tmp0151, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0151.regNro);
	tmp0153 = aarch64_genADD_3(tmp0153, In, tmp0152);
	h2_freeReg(tmp0152.regNro);
	tmp0154 = aarch64_genR_3(tmp0154, tmp0153, immValueZero);
	tmp0155 = aarch64_genMUL_3(tmp0155, tmp0154, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[3][2]))});
	h2_freeReg(tmp0154.regNro);
	tmp0156 = aarch64_genADD_3(tmp0156, sum, tmp0155);
	h2_freeReg(tmp0155.regNro);
	sum = aarch64_genMV_3(sum, tmp0156, immValueZero);
	h2_freeReg(tmp0156.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0158 = aarch64_genMUL_3(tmp0158, ni, Inwidth);
	tmp0159 = aarch64_genADD_3(tmp0159, tmp0158, nj1);
	h2_freeReg(tmp0158.regNro);
	tmp0160 = aarch64_genMUL_3(tmp0160, tmp0159, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0159.regNro);
	tmp0161 = aarch64_genADD_3(tmp0161, In, tmp0160);
	h2_freeReg(tmp0160.regNro);
	tmp0162 = aarch64_genR_3(tmp0162, tmp0161, immValueZero);
	tmp0163 = aarch64_genMUL_3(tmp0163, tmp0162, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[3][3]))});
	h2_freeReg(tmp0162.regNro);
	tmp0164 = aarch64_genADD_3(tmp0164, sum, tmp0163);
	h2_freeReg(tmp0163.regNro);
	sum = aarch64_genMV_3(sum, tmp0164, immValueZero);
	h2_freeReg(tmp0164.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0166 = aarch64_genMUL_3(tmp0166, ni, Inwidth);
	tmp0167 = aarch64_genADD_3(tmp0167, tmp0166, nj2);
	h2_freeReg(tmp0166.regNro);
	tmp0168 = aarch64_genMUL_3(tmp0168, tmp0167, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0167.regNro);
	tmp0169 = aarch64_genADD_3(tmp0169, In, tmp0168);
	h2_freeReg(tmp0168.regNro);
	tmp0170 = aarch64_genR_3(tmp0170, tmp0169, immValueZero);
	tmp0171 = aarch64_genMUL_3(tmp0171, tmp0170, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[3][4]))});
	h2_freeReg(tmp0170.regNro);
	tmp0172 = aarch64_genADD_3(tmp0172, sum, tmp0171);
	h2_freeReg(tmp0171.regNro);
	sum = aarch64_genMV_3(sum, tmp0172, immValueZero);
	h2_freeReg(tmp0172.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0174 = aarch64_genADD_3(tmp0174, line, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(2)});
	ni = aarch64_genMV_3(ni, tmp0174, immValueZero);
	h2_freeReg(tmp0174.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0176 = aarch64_genMUL_3(tmp0176, ni, Inwidth);
	tmp0177 = aarch64_genADD_3(tmp0177, tmp0176, njm2);
	h2_freeReg(tmp0176.regNro);
	tmp0178 = aarch64_genMUL_3(tmp0178, tmp0177, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0177.regNro);
	tmp0179 = aarch64_genADD_3(tmp0179, In, tmp0178);
	h2_freeReg(tmp0178.regNro);
	tmp0180 = aarch64_genR_3(tmp0180, tmp0179, immValueZero);
	tmp0181 = aarch64_genMUL_3(tmp0181, tmp0180, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[4][0]))});
	h2_freeReg(tmp0180.regNro);
	tmp0182 = aarch64_genADD_3(tmp0182, sum, tmp0181);
	h2_freeReg(tmp0181.regNro);
	sum = aarch64_genMV_3(sum, tmp0182, immValueZero);
	h2_freeReg(tmp0182.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0184 = aarch64_genMUL_3(tmp0184, ni, Inwidth);
	tmp0185 = aarch64_genADD_3(tmp0185, tmp0184, njm1);
	h2_freeReg(tmp0184.regNro);
	tmp0186 = aarch64_genMUL_3(tmp0186, tmp0185, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0185.regNro);
	tmp0187 = aarch64_genADD_3(tmp0187, In, tmp0186);
	h2_freeReg(tmp0186.regNro);
	tmp0188 = aarch64_genR_3(tmp0188, tmp0187, immValueZero);
	tmp0189 = aarch64_genMUL_3(tmp0189, tmp0188, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[4][1]))});
	h2_freeReg(tmp0188.regNro);
	tmp0190 = aarch64_genADD_3(tmp0190, sum, tmp0189);
	h2_freeReg(tmp0189.regNro);
	sum = aarch64_genMV_3(sum, tmp0190, immValueZero);
	h2_freeReg(tmp0190.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0192 = aarch64_genMUL_3(tmp0192, ni, Inwidth);
	tmp0193 = aarch64_genADD_3(tmp0193, tmp0192, column);
	h2_freeReg(tmp0192.regNro);
	tmp0194 = aarch64_genMUL_3(tmp0194, tmp0193, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0193.regNro);
	tmp0195 = aarch64_genADD_3(tmp0195, In, tmp0194);
	h2_freeReg(tmp0194.regNro);
	tmp0196 = aarch64_genR_3(tmp0196, tmp0195, immValueZero);
	tmp0197 = aarch64_genMUL_3(tmp0197, tmp0196, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[4][2]))});
	h2_freeReg(tmp0196.regNro);
	tmp0198 = aarch64_genADD_3(tmp0198, sum, tmp0197);
	h2_freeReg(tmp0197.regNro);
	sum = aarch64_genMV_3(sum, tmp0198, immValueZero);
	h2_freeReg(tmp0198.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0200 = aarch64_genMUL_3(tmp0200, ni, Inwidth);
	tmp0201 = aarch64_genADD_3(tmp0201, tmp0200, nj1);
	h2_freeReg(tmp0200.regNro);
	tmp0202 = aarch64_genMUL_3(tmp0202, tmp0201, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0201.regNro);
	tmp0203 = aarch64_genADD_3(tmp0203, In, tmp0202);
	h2_freeReg(tmp0202.regNro);
	tmp0204 = aarch64_genR_3(tmp0204, tmp0203, immValueZero);
	tmp0205 = aarch64_genMUL_3(tmp0205, tmp0204, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[4][3]))});
	h2_freeReg(tmp0204.regNro);
	tmp0206 = aarch64_genADD_3(tmp0206, sum, tmp0205);
	h2_freeReg(tmp0205.regNro);
	sum = aarch64_genMV_3(sum, tmp0206, immValueZero);
	h2_freeReg(tmp0206.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0208 = aarch64_genMUL_3(tmp0208, ni, Inwidth);
	tmp0209 = aarch64_genADD_3(tmp0209, tmp0208, nj2);
	h2_freeReg(tmp0208.regNro);
	tmp0210 = aarch64_genMUL_3(tmp0210, tmp0209, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)});
	h2_freeReg(tmp0209.regNro);
	tmp0211 = aarch64_genADD_3(tmp0211, In, tmp0210);
	h2_freeReg(tmp0210.regNro);
	tmp0212 = aarch64_genR_3(tmp0212, tmp0211, immValueZero);
	tmp0213 = aarch64_genMUL_3(tmp0213, tmp0212, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((Filter[4][4]))});
	h2_freeReg(tmp0212.regNro);
	tmp0214 = aarch64_genADD_3(tmp0214, sum, tmp0213);
	h2_freeReg(tmp0213.regNro);
	sum = aarch64_genMV_3(sum, tmp0214, immValueZero);
	h2_freeReg(tmp0214.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0216 = aarch64_genDIV_3(tmp0216, sum, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((coeff))});
	h2_outputVarName = aarch64_genMV_3(h2_outputVarName, tmp0216, immValueZero);
	h2_freeReg(tmp0216.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	aarch64_genRET_0();
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	h2_end_codeGen = h2_getticks();
	h2_iflush(ptr, h2_asm_pc);

  return ptr;
}

int kernel(imgStruct_t *In, imgStruct_t *Filter,int coeff,int line,int column,int offset)
{
  int sum = 0;
  //printf("FilterHeight : %i\nFilterWidth : %i\n",Filter->width,Filter->height);
  // kernel sum operation
  for (int ki = 0; ki < Filter->height; ki++) {
    for (int kj = 0; kj < Filter->width; kj++) {
        int ni = (line + ki) - offset;
        int nj = (column + kj) - offset;
        sum += In->pixelsArray[ni][nj] * Filter->pixelsArray[ki][kj];
        //printf("In->pixelsArray[%i][%i] : %i\nFilter->pixelsArray[%i][%i] : %i\nsum : %i\n",ni,nj,In->pixelsArray[ni][nj],ki,kj,Filter->pixelsArray[ki][kj],sum);
    }
  }
  //printf("kernel result is : %d\n",sum/coeff);

  return clamp(sum / coeff); // good value for pgm + divide by coefficient of the stencil
}


void convolution(imgStruct_t *In, imgStruct_t *Out, imgStruct_t *Filter,int coeff)
{
  assert (Filter->width == Filter->height); // only square filter
  int offset = Filter->width/2;
  for (int line = offset; line < In->height-offset; line++){
    for (int column = offset; column < In->width-offset; column++){

        Out->pixelsArray[line][column] =  kernel(In,Filter,coeff,line,column,offset); // write result of kernel operation for this pixel
      }
    }
}

void convolutionH4(imgStruct_t* In, imgStruct_t *Out, imgStruct_t *Filter, int coeff)
{
  int result;
  assert (Filter->width == Filter->height);
  int offset = Filter->width/2;
  pifc kernelGenerated = NULL;
  ticks_t startConv = h2_getticks();
  if(Filter->width == 5){
    kernelGenerated = (pifc)h2_malloc(8192);
    kernelGenerated = genKernel5x5 (kernelGenerated, (int**)Filter->pixelsArray, coeff);
  }
  else{
    kernelGenerated = (pifc)h2_malloc(1025);
    kernelGenerated = genKernel3x3 (kernelGenerated, (int**)Filter->pixelsArray, coeff);

  }
  ticks_t endConv = h2_getticks();
  endConv = endConv - startConv;
  //  printf("generation Time compilette : %lu ticks\n",endConv);

  for (int line = offset; line < (In->height)-offset; line++)
    {
      for (int column = offset; column < (In->width)-offset; column++)
        {
           result = kernelGenerated((int *) In->pixelsArray, line, column, In->width, In->height);
          //printf("kernelH4 result is : %d\n",result);
          Out->pixelsArray[line][column] = clamp(result);
          // printf ("%d %d\n\n", GET(Out, line, column), tmpValue);
        }
    }
  //free(kernelGenerated);
}

void compareImages(imgStruct_t *img1, imgStruct_t *img2)
{
  for(int line = 0 ; line < img1->height ; line++)
	{
	  for(int column = 0 ; column < img1->width ; column++)
		{
		  //printf("%i\n",Out->pixelsArray[i][j]);
		  if(img1->pixelsArray[line][column] != img2->pixelsArray[line][column])
			{
			  printf("Alert initial difference at %i %i : abort\n",line, column);
			  exit(-1);
			}
		}
	}
}

void printImage(imgStruct_t *img, int lineMax, int colMax)
{
  int line, column;
  for(int line = 0 ; line < lineMax ; line++)
	{
	  for(int column = 0 ; column < colMax ; column++)
		{
		  printf("%02d ", img->pixelsArray[line][column]);
		}
	  printf("\n");
	}
  printf("\n");
}

int main(int argc, char *argv[])
{
  imgStruct_t *In, *InR, *OutH4, *OutStatic, *Filter;
  char *filterImageName, *inputImageName;
  if (argc < 6)
    {
      printf ("./Stencil <InputImageName> <outputImageName> <outputH4ImageName> <Filter Img> <Coeff Filter>\n");
      exit(-1);
    }

  filterImageName  = argv[4];
  inputImageName = argv[1];
  In     = readPgmImage(inputImageName);
  Filter = readPgmImage(filterImageName);

  int coeff = atoi(argv[5]);
  OutStatic = createImage (In->height, In->width);
  OutH4     = createImage (In->height, In->width);
  InR       = createImage (In->height, In->width);
  //  printImage(In, 5, 5);

  ticks_t startConv = h2_getticks();   // Static convolution
  convolution (In, OutStatic, Filter, coeff);
  ticks_t endConv = h2_getticks();
  endConv = endConv - startConv;
  //  printImage(OutStatic, 5, 5);

  int * tmp = malloc(sizeof(int) * In->width * In->height);
  for(int i = 0 ; i < In->height; i++)
	{
	  for(int j = 0 ; j < In->width ; j++)
		{
		  tmp[i * In->width + j] = In->pixelsArray[i][j];
		}
	}
  InR->pixelsArray = (int **) tmp;
  ticks_t startConvH4 = h2_getticks(); // Compilette convolution
  convolutionH4(InR, OutH4, Filter, coeff);
  ticks_t endConvH4 = h2_getticks();
  endConvH4 = endConvH4 - startConvH4;
  //  printImage(OutH4, 5, 5);

  compareImages(OutH4, OutStatic);
  printf("%s;%ix%i;%ix%i;%lld;%lld\n", filterImageName, Filter->width, Filter->height, In->width, In->height, endConv, endConvH4);
#if 0
  writePgmImage(OutStatic, argv[2]);
  writePgmImage(OutH4,argv[3]);
#endif
  return 0;
}
