/* Begin Header autogenerated part */
#ifndef H2_COMMON
#define H2_COMMON
/* Common HybroGen inserted code */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdint.h>

bool h2_codeGenerationOK;	 // Does code generation fail ?
typedef int32_t h2_regSet_t; // Register set (signed, use -1 when not allocated)
typedef unsigned long long ticks_t;
static  ticks_t h2_start_codeGen, h2_end_codeGen;

typedef enum { H2REGISTER,    H2VALUE, } VALORREG;
typedef struct
{
  int ValOrReg; // is H2REGISTER or immediate VALUE ?
  char arith;   // int, flt or other arithmetic
  int vLen;     // vector len
  int wLen;     // word len
  int regNro;   // register number (if register)
  int valueImm; // immediate value (if not register)
  bool dontFree; // if register, don't free
} h2_sValue_t;
#define sValueDef(VALUE, ARITH, VECTORLEN, WORDLEN, REGNO, IMMVAL) ((h2_sValue_t){.ValOrReg = VALUE, .arith = ARITH, .vLen = VECTORLEN, .wLen = WORDLEN, .regNro = REGNO, .valueImm = IMMVAL})
#define intsValue(V) sValueDef(H2VALUE, 'i', 1, 32, -1, V)
#define immValueZero intsValue(0)
// Usefull macro instruction to simplify instruction selector code
#define isInt64_1(P)  ((P.arith == 'i') && (P.wLen <= 64) && (P.vLen == 1))
#define isInt32_1(P)  ((P.arith == 'i') && (P.wLen <= 32) && (P.vLen == 1))
#define isInt0(P)     ((P.arith == 'i') && (P.ValOrReg == H2VALUE) && (0 == P.valueImm))
#define isInt1(P)     ((P.arith == 'i') && (P.ValOrReg == H2VALUE) && (1 == P.valueImm))
#define isValue(P)    ((P.arith == 'i') && (P.ValOrReg == H2VALUE))
#define isReg32(P, X) ((P.arith == 'i') && (P.ValOrReg == H2REGISTER) && (X == P.regNro))
#define isRRR(P0, P1, P2) (P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2REGISTER)
#define isRRV(P0, P1, P2) (P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)


typedef union {
    float f;
    unsigned long i;
} h2_float_int_u;

static int h2_log2(int value)
{ // integer logarithm
  int log = 0;
  while (value >>= 1) { ++log; }
  return log;
}

void printRev (int value, int pos)
{ // Print a bitset in reversal order (recursive)
  if (pos != 0)
	printRev (value >> 1, pos - 1);
  printf ("%1c", (value % 2)?'.':'F');
}

// Dynamic register allocation handling
// h2_regSet mask : 0 mean free register, 1 register set
//  3           2            1  Bit position = reg Number
// 1098 7654 3210 9876 5432 1098 7654 3210
// 1111 1111 1111 1111 0000 0001 0011 1111
typedef struct
{	// Register allocation sets for
  	// int, float, vector of ints, vector of floats
  int intSet, fltSet, vintSet, vfltSet ;
} h2_RegSets_t;

h2_RegSets_t h2_regSet, h2_regSetInit;

// Print integer register set
void printRegState(char * msg, int regNo, int registerSet)
{
  int count = 8 * sizeof (registerSet) - 1;
  h2_regSet_t tmpReg = registerSet;
  printf ("%02d : Reg %s\n", regNo, msg);
  for (int i = count; i >= 0; i--) // Tens
	(0 == (i % 10))?printf ("%d", i/10):printf (" ");
  printf ("\n");
  for (int i = count; i >= 0; i--) // Unit
	  printf ("%d", i%10);
  printf ("\n");
  printRev (tmpReg, count); // Bit set
  printf ("\n");
}

// Initialize registers sets allocation
static void h2_initRegisterMasks(int intmask, int fltmask, int vectorintmask, int vectorfltmask)
{ // See H2SymbolTable & H2RegisterBank
  h2_regSetInit.intSet  = intmask;
  h2_regSetInit.fltSet  = fltmask;
  h2_regSetInit.vintSet = vectorintmask;
  h2_regSetInit.vfltSet = vectorfltmask;
}

static void h2_resetRegisterMasks() // Reset register set from initializers
{
  h2_regSet.intSet  = h2_regSetInit.intSet;
  h2_regSet.fltSet  = h2_regSetInit.fltSet;
  h2_regSet.vintSet = h2_regSetInit.vintSet;
  h2_regSet.vfltSet = h2_regSetInit.vfltSet;
#ifdef H2_DEBUG_REGISTER
  printRegState("RESET", -1, h2_regSet.intSet);
#endif // H2_DEBUG_REGISTER
}
int h2_getReg () // Get new register
{
  /* Search for the 1st free register */
  h2_regSet_t tmpReg = h2_regSet.intSet;
  for (int i = 0; i < 8 * sizeof (h2_regSet.intSet); i++)
	{
	  if (tmpReg % 2 == 0)
		{						/* Free register found */
		  h2_regSet.intSet = h2_regSet.intSet | (1 << i); /* Update regSet */
#ifdef H2_DEBUG_REGISTER
		  printRegState("GET", i, h2_regSet.intSet);
#endif // H2_DEBUG_REGISTER
		  return i;
		}
	  tmpReg >>= 1;
	}
  printf ("Register allocation failed\n");
  h2_codeGenerationOK = false;
  return -1;
}

// h2_regSet_t regToBeFreed[32];

void h2_freeReg (h2_regSet_t v) // Free a register
{
#if 1 // TODO : To be rethinked
      // Is the register freeable ?
  int isOK = (h2_regSetInit.intSet >> v) & 1;
  if (0 == isOK)
    {
	h2_regSet.intSet = h2_regSet.intSet & ~(1 << v); /* Update regSet */
#ifdef H2_DEBUG_REGISTER
    printRegState("FREE", v, h2_regSet.intSet);
#endif // H2_DEBUG_REGISTER
    }
#endif
}
#endif /*H2_COMMON*/
#ifndef H2_RISCV_RV32G
#define H2_RISCV_RV32G

#define H2SYS 					/* Has  operating system */

#include <stdint.h>
#ifdef H2SYS
#include <sys/mman.h>
#endif

typedef uint32_t    h2_insn_t;
static  h2_insn_t   *h2_asm_pc;
static  h2_insn_t    *h2_save_asm_pc;
static int h2_riscvVectorLen = 1;
static int h2_riscvVectorWidth = 1;
/*
https://stackoverflow.com/questions/52187221/how-to-calculate-the-no-of-clock-cycles-in-riscv-clang
*/

ticks_t h2_getticks(void)
{
    unsigned long dst;
    // output into any register, likely a0
    // regular instruction:
    asm volatile ("csrrs %0, 0xc00, x0" : "=r" (dst) );
    // regular instruction with symbolic csr and register names
    // asm volatile ("csrrs %0, cycle, zero" : "=r" (dst) );
    // pseudo-instruction:
    // asm volatile ("csrr %0, cycle" : "=r" (dst) );
    // pseudo-instruction:
    //asm volatile ("rdcycle %0" : "=r" (dst) );
    return dst;
}


static void h2_iflush(void *addr, void *last)
{
#ifdef H2SYS
    long pageSize= getpagesize();
    void *ptmp= (char *)((long)addr & ~(pageSize - 1));
    if (mprotect(ptmp, (last - addr), PROT_READ | PROT_WRITE | PROT_EXEC))
    {
        perror("iflush: mprotect");
        exit(-1);
    }
    __clear_cache((char *)addr, (char *)last);
#endif
#ifdef H2_DEBUG
	uint64_t codeGenDuration = h2_end_codeGen - h2_start_codeGen;
	uint64_t insnGenerated = (last-addr)/sizeof (h2_insn_t);
    printf ("Flush data cache from %p to %p\n", addr, last);
	printf ("%lld insn generated in %lld ticks. %lld ticks / insn\n", insnGenerated, codeGenDuration, codeGenDuration/insnGenerated);
#endif
	if (!h2_codeGenerationOK)
	  {
		fprintf (stderr, "(iflush) Failed code generation\n");
		exit(-5);
	  }
}

static h2_insn_t *h2_malloc (size_t size)
{
  return malloc (size);
}


#endif /*H2_RISCV_RV32G*/
/* In memory instruction generator */
#define riscv_G32(INSN){ *(h2_asm_pc++) = (INSN);}

/* Single instruction binary code generator*/
void RV32I_RET__I_32_1(){ /* RET */
	riscv_G32(((0x8067 >> 0) & 0xffffffff)); \

#ifdef H2_DEBUG_INSN
printf("%p : RV32I_RET__I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_SUB_RRR_I_32_1(int r3,int r1,int r2){ /* SUB */
	riscv_G32(((0x20 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SUB_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_MV_RR_I_32_1(int r0,int r1){ /* MV */
	riscv_G32(((0x0 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r0 & 0x1f) << 7)|((0x13 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_MV_RR_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_MV_RI_I_32_1(int r3,int i1){ /* MV */
	riscv_G32(((i1 & 0xfff) << 20)|((0x6 & 0xff) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_MV_RI_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_SB_RRI_I_8_1(int r1,int r2,int i1){ /* W */
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SB_RRI_I_8_1\n", h2_asm_pc);
#endif
}
void RV32I_SH_RRI_I_16_1(int r1,int r2,int i1){ /* W */
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SH_RRI_I_16_1\n", h2_asm_pc);
#endif
}
void RV32I_SW_RRI_I_32_1(int r1,int r2,int i1){ /* W */
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x2 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SW_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_LB_RRI_I_8_1(int r3,int r1,int i1){ /* R */
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x3 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_LB_RRI_I_8_1\n", h2_asm_pc);
#endif
}
void RV32I_LH_RRI_I_16_1(int r3,int r1,int i1){ /* R */
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x3 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_LH_RRI_I_16_1\n", h2_asm_pc);
#endif
}
void RV32I_LW_RRI_I_32_1(int r3,int r1,int i1){ /* R */
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x2 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x3 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_LW_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void RV32M_MUL_RRR_I_32_1(int r3,int r1,int r2){ /* MUL */
	riscv_G32(((0x1 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32M_MUL_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_ADDI_RRI_I_32_1(int r1,int r0,int i0){ /* ADD */
	riscv_G32(((i0 & 0xfff) << 20)|((r0 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r1 & 0x1f) << 7)|((0x13 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_ADDI_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_ADD_RRR_I_32_1(int r3,int r1,int r2){ /* ADD */
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_ADD_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_SLLI_RRI_I_32_1(int r3,int r1,int i0){ /* SL */
	riscv_G32(((0x0 & 0x7f) << 25)|((i0 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SLLI_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_SLL_RRR_I_32_1(int r3,int r1,int r2){ /* SL */
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SLL_RRR_I_32_1\n", h2_asm_pc);
#endif
}
h2_sValue_t riscv_genSUB_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t riscv_genMV_2(h2_sValue_t P0,h2_sValue_t P1);
h2_sValue_t riscv_genRET_0();
h2_sValue_t riscv_genSL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t riscv_genR_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t riscv_genW_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t riscv_genADD_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t riscv_genMUL_4(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2,h2_sValue_t P3);
h2_sValue_t riscv_genSUB_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for SUB instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
/* -*- c -*- */
// if 2 operands are constants do substraction evaluation (Thanks Kilian for the bug report)
if  ((P2.ValOrReg == H2VALUE) && (P1.ValOrReg == H2VALUE) && (P1.arith == 'i')&& (P2.arith == 'i'))
{
  return (h2_sValue_t) {H2VALUE, P1.arith, P1.vLen, P1.wLen, -1, P1.valueImm - P2.valueImm };
}

/* -*- c -*- */
if  ((P2.ValOrReg == H2VALUE) && (P2.arith == 'i'))
{
	h2_sValue_t PTMP = {H2REGISTER, P2.arith, P2.vLen, P2.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RRI sub (riscv)\\n");
    #endif
	P2 = riscv_genMV_2(PTMP,  P2);
}

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2REGISTER)
    {
	RV32I_SUB_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, SUB instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genMV_2(h2_sValue_t P0,h2_sValue_t P1)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for MV instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for MV

// No specific optimisation for MV/riscv

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER)
    {
	RV32I_MV_RR_I_32_1(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2VALUE)
    {
	RV32I_MV_RI_I_32_1(P0.regNro, P1.valueImm);
	return P0;
    }
	printf ("Warning, MV instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genRET_0()
{
// No generic optimisation for RET

// No specific optimisation for RET/riscv

RV32I_RET__I_32_1();
	
}
h2_sValue_t riscv_genSL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for SL instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for SL

// No specific optimisation for SL/riscv

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_SLLI_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2REGISTER)
    {
	RV32I_SLL_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, SL instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genR_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for R instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for R

// No specific optimisation for R/riscv

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_LB_RRI_I_8_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_LH_RRI_I_16_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_LW_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }
	printf ("Warning, R instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genW_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for W instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for W

/* -*- c -*- */
if (isValue(P1))
  { // Store constant (Should use RRI variant)
	h2_sValue_t PTMP = {H2REGISTER, P1.arith, P1.vLen, P1.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RI W (riscv)\\n");
    #endif
	// MV const in tmp register
	P1 = riscv_genMV_2(PTMP,  P1);
	// No return continue instruction selection
  }

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P1.arith == 'i') && (P1.wLen <= 8) && (P1.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_SB_RRI_I_8_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 16) && (P1.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_SH_RRI_I_16_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_SW_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }
	printf ("Warning, W instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genADD_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for ADD instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
/* -*- c -*- */
// If 2 operands are constants do addition
if  ((P2.ValOrReg == H2VALUE) && (P1.ValOrReg == H2VALUE) && (P1.arith == 'i')&& (P2.arith == 'i'))
{
  return sValueDef(H2VALUE, P1.arith, P1.vLen, P1.wLen, -1, P1.valueImm + P2.valueImm );
}
if (isInt0 (P2))
  { // P0 = P1 + 0
    #ifdef H2_DEBUG_INSN
	printf ("Optim add for 0 (generic) return reg %d\n", P1.regNro);
    #endif
	P1.dontFree = true;
	return P1;
  }
if (isInt0 (P1))
  { // P0 = 0 + P2
    #ifdef H2_DEBUG_INSN
    printf ("Optim add for 0  (generic) return reg %d\n", P2.regNro);
    #endif
	P2.dontFree = true;
    return P2;
  }

// No specific optimisation for ADD/riscv

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_ADDI_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2REGISTER)
    {
	RV32I_ADD_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, ADD instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genMUL_4(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2,h2_sValue_t P3)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for MUL instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
/* -*- c -*- */
  // if 2 operands are constants do multiplication evaluation (Thanks Kilian for the bug report)
  if  ((P2.ValOrReg == H2VALUE) && (P1.ValOrReg == H2VALUE) && (P1.arith == 'i')&& (P2.arith == 'i'))
  {
    return (h2_sValue_t) {H2VALUE, P1.arith, P1.vLen, P1.wLen, -1, P1.valueImm * P2.valueImm };
  }
  if (isInt0(P2) || isInt0(P1))
   {    // X * 0 = 0 Avoid 1 operation mul & 1 mv
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *0 P2 (generic)\n");
        #endif
        return immValueZero;
    }
  if (isInt1(P2))
    { // X * 1 = X propagate register result
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *1 P2 (generic)\n");
        #endif
		P1.dontFree = true;
        return P1;
    }
  if (isInt1(P1))
    { // 1 * X = X propagate register result
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *1 P1 (generic)\n");
        #endif
		P2.dontFree = true;
        return P2;
    }

/* -*- c -*- */
if  ((P2.ValOrReg == H2VALUE) && (P2.arith == 'i'))
{
	h2_sValue_t PTMP = {H2REGISTER, P2.arith, P2.vLen, P2.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RRI mul (aarch64)\n");
    #endif
	P2 = riscv_genMV_2(PTMP,  P2);
	// No return continue instruction selection
}

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2REGISTER)
    {
	RV32M_MUL_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, MUL instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}

/* End Header autogenerated part */
/* -*- c -*- */
// https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/mesa/math/m_matrix.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <strings.h>
#define T 4
typedef int d_t;
typedef d_t matrix_t [T][T];
typedef d_t vector_t [T];
typedef d_t (*pifvv)(vector_t, vector_t);

pifvv genVectorMatrixProduct(pifvv ptr, matrix_t m)
{
	/* Code Generation of 5 instructions */
	/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t o = {H2REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t i = {H2REGISTER, 'i', 1, 32, 11, 0};
	h2_sValue_t h2_outputVarName = {H2REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t READ_i_0 = {H2REGISTER, 'i', 1, 32, 12, 0};
	h2_sValue_t READ_i_4 = {H2REGISTER, 'i', 1, 32, 13, 0};
	h2_sValue_t READ_i_8 = {H2REGISTER, 'i', 1, 32, 14, 0};
	h2_sValue_t READ_i_12 = {H2REGISTER, 'i', 1, 32, 15, 0};
	h2_sValue_t tmp0000 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0001 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0002 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0003 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0004 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0005 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0006 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0007 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0008 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0009 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0010 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0011 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0012 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0013 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0014 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0015 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0016 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0017 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0018 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0019 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0020 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0021 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0022 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0023 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0024 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0025 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0026 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0027 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0028 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0029 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0030 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0031 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0032 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0033 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0034 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0035 = {H2REGISTER, 'i', 1, 32, -1, 0};

	/* Label  table :*/
/* No label table to avoid C warning for empty table ... */
	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = true;
	h2_start_codeGen = h2_getticks();
	h2_initRegisterMasks(0xFF1F, 0, 0, 0);
	h2_resetRegisterMasks();
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask initialization\n");
	#endif // H2_DEBUG_REGISTER
		tmp0000 = riscv_genADD_3(tmp0000, o, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)(0)});
							tmp0001 = riscv_genADD_3(tmp0001, i, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)(0)});
						READ_i_0 = riscv_genR_3(READ_i_0, tmp0001, immValueZero);
					tmp0002 = riscv_genMUL_4(tmp0002, READ_i_0, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[0][0]))}, immValueZero);
							tmp0003 = riscv_genADD_3(tmp0003, i, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)(4)});
						READ_i_4 = riscv_genR_3(READ_i_4, tmp0003, immValueZero);
					tmp0004 = riscv_genMUL_4(tmp0004, READ_i_4, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[1][0]))}, immValueZero);
				tmp0005 = riscv_genADD_3(tmp0005, tmp0002, tmp0004);
				if (!tmp0005.dontFree) h2_freeReg(tmp0002.regNro);
				if (!tmp0005.dontFree) h2_freeReg(tmp0004.regNro);
						tmp0006 = riscv_genADD_3(tmp0006, i, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)(8)});
					READ_i_8 = riscv_genR_3(READ_i_8, tmp0006, immValueZero);
				tmp0007 = riscv_genMUL_4(tmp0007, READ_i_8, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[2][0]))}, immValueZero);
			tmp0008 = riscv_genADD_3(tmp0008, tmp0005, tmp0007);
			if (!tmp0008.dontFree) h2_freeReg(tmp0005.regNro);
			if (!tmp0008.dontFree) h2_freeReg(tmp0007.regNro);
					tmp0009 = riscv_genADD_3(tmp0009, i, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)(12)});
				READ_i_12 = riscv_genR_3(READ_i_12, tmp0009, immValueZero);
			tmp0010 = riscv_genMUL_4(tmp0010, READ_i_12, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[3][0]))}, immValueZero);
		tmp0011 = riscv_genADD_3(tmp0011, tmp0008, tmp0010);
		if (!tmp0011.dontFree) h2_freeReg(tmp0008.regNro);
		if (!tmp0011.dontFree) h2_freeReg(tmp0010.regNro);
	riscv_genW_3(tmp0000, tmp0011, immValueZero);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
		tmp0012 = riscv_genADD_3(tmp0012, o, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)(4)});
					tmp0013 = riscv_genMUL_4(tmp0013, READ_i_0, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[0][1]))}, immValueZero);
					tmp0014 = riscv_genMUL_4(tmp0014, READ_i_4, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[1][1]))}, immValueZero);
				tmp0015 = riscv_genADD_3(tmp0015, tmp0013, tmp0014);
				if (!tmp0015.dontFree) h2_freeReg(tmp0013.regNro);
				if (!tmp0015.dontFree) h2_freeReg(tmp0014.regNro);
				tmp0016 = riscv_genMUL_4(tmp0016, READ_i_8, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[2][1]))}, immValueZero);
			tmp0017 = riscv_genADD_3(tmp0017, tmp0015, tmp0016);
			if (!tmp0017.dontFree) h2_freeReg(tmp0015.regNro);
			if (!tmp0017.dontFree) h2_freeReg(tmp0016.regNro);
			tmp0018 = riscv_genMUL_4(tmp0018, READ_i_12, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[3][1]))}, immValueZero);
		tmp0019 = riscv_genADD_3(tmp0019, tmp0017, tmp0018);
		if (!tmp0019.dontFree) h2_freeReg(tmp0017.regNro);
		if (!tmp0019.dontFree) h2_freeReg(tmp0018.regNro);
	riscv_genW_3(tmp0012, tmp0019, immValueZero);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
		tmp0020 = riscv_genADD_3(tmp0020, o, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)(8)});
					tmp0021 = riscv_genMUL_4(tmp0021, READ_i_0, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[0][2]))}, immValueZero);
					tmp0022 = riscv_genMUL_4(tmp0022, READ_i_4, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[1][2]))}, immValueZero);
				tmp0023 = riscv_genADD_3(tmp0023, tmp0021, tmp0022);
				if (!tmp0023.dontFree) h2_freeReg(tmp0021.regNro);
				if (!tmp0023.dontFree) h2_freeReg(tmp0022.regNro);
				tmp0024 = riscv_genMUL_4(tmp0024, READ_i_8, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[2][2]))}, immValueZero);
			tmp0025 = riscv_genADD_3(tmp0025, tmp0023, tmp0024);
			if (!tmp0025.dontFree) h2_freeReg(tmp0023.regNro);
			if (!tmp0025.dontFree) h2_freeReg(tmp0024.regNro);
			tmp0026 = riscv_genMUL_4(tmp0026, READ_i_12, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[3][2]))}, immValueZero);
		tmp0027 = riscv_genADD_3(tmp0027, tmp0025, tmp0026);
		if (!tmp0027.dontFree) h2_freeReg(tmp0025.regNro);
		if (!tmp0027.dontFree) h2_freeReg(tmp0026.regNro);
	riscv_genW_3(tmp0020, tmp0027, immValueZero);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
		tmp0028 = riscv_genADD_3(tmp0028, o, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)(12)});
					tmp0029 = riscv_genMUL_4(tmp0029, READ_i_0, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[0][3]))}, immValueZero);
					tmp0030 = riscv_genMUL_4(tmp0030, READ_i_4, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[1][3]))}, immValueZero);
				tmp0031 = riscv_genADD_3(tmp0031, tmp0029, tmp0030);
				if (!tmp0031.dontFree) h2_freeReg(tmp0029.regNro);
				if (!tmp0031.dontFree) h2_freeReg(tmp0030.regNro);
				tmp0032 = riscv_genMUL_4(tmp0032, READ_i_8, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[2][3]))}, immValueZero);
			tmp0033 = riscv_genADD_3(tmp0033, tmp0031, tmp0032);
			if (!tmp0033.dontFree) h2_freeReg(tmp0031.regNro);
			if (!tmp0033.dontFree) h2_freeReg(tmp0032.regNro);
			tmp0034 = riscv_genMUL_4(tmp0034, READ_i_12, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((m[3][3]))}, immValueZero);
		tmp0035 = riscv_genADD_3(tmp0035, tmp0033, tmp0034);
		if (!tmp0035.dontFree) h2_freeReg(tmp0033.regNro);
		if (!tmp0035.dontFree) h2_freeReg(tmp0034.regNro);
	riscv_genW_3(tmp0028, tmp0035, immValueZero);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	riscv_genRET_0();
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	h2_end_codeGen = h2_getticks();
	h2_iflush(ptr, h2_asm_pc);

  return ptr;
}

d_t VectorMatrixProductUnrolled (vector_t o, vector_t i, matrix_t m)
{
  o[0] = i[0]*m[0][0] + i[1]*m[1][0] + i[2]*m[2][0] + i[3]*m[3][0];
  o[1] = i[0]*m[0][1] + i[1]*m[1][1] + i[2]*m[2][1] + i[3]*m[3][1];
  o[2] = i[0]*m[0][2] + i[1]*m[1][2] + i[2]*m[2][2] + i[3]*m[3][2];
  o[3] = i[0]*m[0][3] + i[1]*m[1][3] + i[2]*m[2][3] + i[3]*m[3][3];
  return o[3];
}

#if 0 // What the binary code should be with a translation matrix
d_t VectorMatrixProductUnrolledSR(vector_t o, vector_t i, matrix_t m)
{

  o[0] = m[0][0] * i[0] +                                 + m[3][0] * i[3];
  o[1] =                  m[1][1] * i[1] +                + m[3][1] * i[3];
  o[2] =                                   m[2][2] * i[2] + m[3][2] * i[3];
  o[3] =                                                  +           i[3];
  return o[3];
}
#endif
d_t VectorMatrixProduct (vector_t o, vector_t i, matrix_t m)
{
  for (int column = 0; column < T; column++)
    {
      o[column] = 0;
      // printf("o[%d] = ",column);
      for (int line = 0; line < T; line++)
        {
          o[column] += i[line] * m[line][column];
          //          printf("+ i[%d]*m[%d][%d]", line, line, column);
        }
      //      printf("\n");
    }
  //     printf("\n");
  return o[3];
}


int VectorMatrixProductCount(matrix_t mat)
{
  int op = 0;
  for (int column = 0; column < T; column++)
    {
      for (int line = 0; line < T; line++)
        {
          switch (mat[line][column])
            {
            case 0 : op += 0; break;
            case 1 : op += 1; break;
            default: op += 2; break;
            }
        }
    }
  return op;
}


void printMatrix (matrix_t m, char msg[])
{
  printf ("%s:\n", msg);
  for (int column = 0; column < T; column++)
    {
      for (int line = 0; line < T; line++)
        {
          printf ("%4d ", m[line][column]);
        }
      printf ("\n");
    }
  printf ("\n");
}

void printVector (vector_t v, char msg[])
{
  for (int i = 0; i < T; i++)
    printf ("%4d ", v[i]);
  printf ("%s\n", msg);
}

bool vectorCompare(vector_t ref, vector_t other, char * msg, int doPrint)
{
  int has_differences = false;
  for (int i = 0; i < T; i++)
    {
      if (ref[i] != other[i])
        has_differences = true;
      if (doPrint)
        printf("%4d ", other[i]);
    }
  printf("%s : ", msg);
  printf(" %s\n", (has_differences)?"NOT OK":"OK");
  return has_differences;
}

int main (int argc, char *argv[])
{
  matrix_t m;
  char *matrixName;
  vector_t g0  = {1, 2, 3, 4}, g1  = {5, 6, 7, 8};
  vector_t tmp0, tmp1, utmp0, utmp1, ctmp0, ctmp1;
  uint64_t dateStart, dateStop, timeGeneral, timeCompilette, timeUnrolled;
  pifvv vmProduct;
  int tmp, doPrint;
  unsigned long acc;
  bool resultValid;

  if (argc != 18)
    {
      printf ("Not enough arguments %d\n", argc);
      printf ("VectorMatrix MatrixName M11 M12 ... M44\n");
      exit (-1);
    }
  doPrint = 1;
  acc = 0;
  matrixName = argv[1];
  for (int line = 0; line < 4; line++)
    for (int column = 0; column < 4; column++)
      {
        m[line][column] = atoi (argv[2 + line*4+column]);
      }
  printMatrix(m, matrixName);
  tmp = VectorMatrixProductCount (m);
  printf("Operation count Matrix %s : %d speedup %.1f\n", matrixName, tmp, 32.0/tmp);

#define DO(INSN, REPEAT, TIME) {dateStart = h2_getticks();for (int i = 0; i < REPEAT; i++) INSN;  dateStop = h2_getticks(); TIME = dateStop - dateStart;}

  printVector (g1, "Input  vector");
  acc += VectorMatrixProduct (tmp0, g0, m); /* Cold start */
  DO(acc += VectorMatrixProduct (tmp1, g1, m), 1000, timeGeneral)
  printVector (tmp1, "Output vector   (general)");

#if 0 // Possible test with a source level unrolled version
  acc += VectorMatrixProductUnrolled (utmp0, g0, m);
  DO(acc += VectorMatrixProductUnrolled (utmp1, g1, m), 1000, timeUnrolled);
  vectorCompare(tmp1, utmp1, "Unrolled tmp0", doPrint);
#endif

  vmProduct = (pifvv) h2_malloc(1024);
  vmProduct = genVectorMatrixProduct (vmProduct, m);
  acc += vmProduct (ctmp0, g0);
  DO(acc += vmProduct (ctmp1, g1), 1000, timeCompilette);
    
  resultValid = vectorCompare(tmp1, ctmp1, "Compilette tmp1", doPrint);
  
  printf ("General    ticks %lu\n", timeGeneral);
  //  printf ("Unrolled   ticks %lu\n", timeUnrolled);
  printf ("Compilette ticks %lu\n", timeCompilette);
  //  printf ("Speedups unrolled   : %.2f%%\n", (float) 100.0*timeGeneral/timeUnrolled);
  printf ("Speedups compilette : %.2f%%\n", (float) 100.0*timeGeneral/timeCompilette);
  printf ("Accumulator value to avoid hard optimizations %ld\n", acc);
  return resultValid;
}
