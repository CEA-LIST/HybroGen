/* Begin Header autogenerated part */
#ifndef H2_COMMON
#define H2_COMMON
/* Common HybroGen inserted code */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdint.h>

bool h2_codeGenerationOK;	 // Does code generation fail ?
typedef int32_t h2_regSet_t; // Register set (signed, use -1 when not allocated)
typedef unsigned long long ticks_t;
static  ticks_t h2_start_codeGen, h2_end_codeGen;

typedef struct
{
  int ValOrReg; // is register or immediate value ?
  char arith;   // int, flt or other arithmetic
  int vLen;     // vector len
  int wLen;     // word len
  int regNro;   // register number (if register)
  int valueImm; // immediate value (if not register)
} h2_sValue_t;

typedef enum { REGISTER,    VALUE, } VALORREG;

typedef union {
    float f;
    unsigned long i;
} h2_float_int_u;

static int h2_log2(int value)
{
  int log = 0;
  while (value >>= 1) { ++log; }
  return log;
}

void printRev (int value, int pos)
{
  if (pos != 0)
	printRev (value >> 1, pos - 1);
  printf ("%1c", (value % 2)?'.':'F');
}


// Dynamic register allocation handling
// h2_regSet mask : 0 mean free register, 1 register set
//  3           2            1  Bit position = reg Number
// 1098 7654 3210 9876 5432 1098 7654 3210
// 1111 1111 1111 1111 0000 0001 0011 1111
typedef struct
{	// Register allocation sets for
  	// int, float, vector of ints, vector of floats
  int intSet, fltSet, vintSet, vfltSet ;
} h2_RegSets_t;

h2_RegSets_t h2_regSet, h2_regSetInit;

// Initialize registers sets allocation
// See H2SymbolTable & H2RegisterBank
static void h2_initRegisterMasks(int intmask, int fltmask, int vectorintmask, int vectorfltmask)
{
  h2_regSetInit.intSet  = intmask;
  h2_regSetInit.fltSet  = fltmask;
  h2_regSetInit.vintSet = vectorintmask;
  h2_regSetInit.vfltSet = vectorfltmask;
}
// Reset register set from initializers
static void h2_resetRegisterMasks()
{
  h2_regSet.intSet  = h2_regSetInit.intSet;
  h2_regSet.fltSet  = h2_regSetInit.fltSet;
  h2_regSet.vintSet = h2_regSetInit.vintSet;
  h2_regSet.vfltSet = h2_regSetInit.vfltSet;
}
// Print integer register set
void printRegState(char * msg, int regNo)
{
  int count = 8 * sizeof (h2_regSet.intSet) - 1;
  h2_regSet_t tmpReg = h2_regSet.intSet;
  printf ("Reg %10s (%d)\n", msg, regNo);
  for (int i = count; i >= 0; i--) // Tens
	if (0 == (i % 10))
	  printf ("%d", i/10);
	else
	  printf (" ");
  printf ("\n");
  for (int i = count; i >= 0; i--) // Unit
	  printf ("%d", i%10);
  printf ("\n");
  printRev (tmpReg, count); // Bit set
  printf ("\n");
}

int h2_getReg () /* Get new register */
{
  /* Search for the 1st free register */
  h2_regSet_t tmpReg = h2_regSet.intSet;
  for (int i = 0; i < 8 * sizeof (h2_regSet.intSet); i++)
	{
	  if (tmpReg % 2 == 0)
		{						/* Free register found */
		  h2_regSet.intSet = h2_regSet.intSet | (1 << i); /* Update regSet */
#ifdef H2_DEBUG_REGISTER
		  printRegState("get", i);
#endif // H2_DEBUG_REGISTER
		  return i;
		}
	  tmpReg >>= 1;
	}
  printf ("Register allocation failed\n");
  h2_codeGenerationOK = false;
  return -1;
}

void h2_freeReg (h2_regSet_t v)
{
  int isOK = (h2_regSetInit.intSet >> v) & 1;

  if (0 == isOK)
	h2_regSet.intSet = h2_regSet.intSet & ~(1 << v); /* Update regSet */
#ifdef H2_DEBUG_REGISTER
  printRegState("Free", v);
#endif // H2_DEBUG_REGISTER
}

#endif /*H2_COMMON*/
#ifndef H2_AARCH64
#define H2_AARCH64

#define H2SYS 					/* Has  operating system */

#ifdef H2SYS
#include <sys/mman.h>
#endif

typedef uint32_t   h2_insn_t;
static  h2_insn_t  *h2_asm_pc;
static  h2_insn_t  *h2_save_asm_pc;
#define H2Aarch64SP  (h2_sValue_t) {REGISTER, 'i', 1, 32, 31, 0}
/* aarch64 / power examples :
   https://github.com/FFTW/fftw3/blob/master/kernel/cycle.h */

static inline ticks_t h2_getticks(void)
{
  uint64_t Rt;
  asm volatile("mrs %0,  CNTVCT_EL0" : "=r" (Rt));
  return Rt;
}

static void h2_iflush(void *addr, void *last)
{
#ifdef H2SYS
  __clear_cache((char *)addr, (char *)last); // Flush data cache where binary code were written  long pageSize= getpagesize();              // Make the page executable
  void *ptmp= (char *)((long)addr & ~(pageSize - 1));
  if (mprotect(ptmp, (last - addr), PROT_READ | PROT_WRITE | PROT_EXEC))
    {
      perror("iflush: mprotect");
      exit(-1);
    }
#endif
#ifdef H2_DEBUG
	uint64_t codeGenDuration = h2_end_codeGen - h2_start_codeGen;
	uint64_t insnGenerated = (last-addr)/sizeof (h2_insn_t);
    printf ("Flush data cache from %p to %p\n", addr, last);
	printf ("%ld insn generated in %ld ticks. %ld ticks / insn\n", insnGenerated, codeGenDuration, codeGenDuration/insnGenerated);
#endif
	if (!h2_codeGenerationOK)
	  {
		fprintf (stderr, "(iflush) Failed code generation\n");
		exit(-5);
	  }
}

static h2_insn_t *h2_malloc (size_t size)
{
  return malloc (size);
}


#endif /* H2_AARCH64 */
/* In memory instruction generator */
#define aarch64_G32(INSN){ *(h2_asm_pc++) = (INSN);}

/* Single instruction binary code generator*/
void A64_RET__I_64_1(){ /* ret */
	aarch64_G32(((0xd65f03c0 >> 0) & 0xffffffff)); \

#ifdef H2_DEBUG_INSN
printf("%p : A64_RET__I_64_1\n", h2_asm_pc);
#endif
}
void A64_SUB_RRR_I_8_8(int r0,int r1,int r2){ /* sub */
	aarch64_G32(((0x171 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRR_I_8_8\n", h2_asm_pc);
#endif
}
void A64_SUB_RRR_I_8_16(int r0,int r1,int r2){ /* sub */
	aarch64_G32(((0x371 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRR_I_8_16\n", h2_asm_pc);
#endif
}
void A64_SUB_RRR_I_16_8(int r0,int r1,int r2){ /* sub */
	aarch64_G32(((0x373 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRR_I_16_8\n", h2_asm_pc);
#endif
}
void A64_SUB_RRR_I_16_4(int r0,int r1,int r2){ /* sub */
	aarch64_G32(((0x173 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRR_I_16_4\n", h2_asm_pc);
#endif
}
void A64_SUB_RRR_I_32_1(int r0,int r1,int r2){ /* sub */
	aarch64_G32(((0x258 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x0 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void A64_SUB_RRI_I_32_1(int r0,int r1,int i0){ /* sub */
	aarch64_G32(((0x144 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void A64_SUB_RRR_I_32_2(int r0,int r1,int r2){ /* sub */
	aarch64_G32(((0x175 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRR_I_32_2\n", h2_asm_pc);
#endif
}
void A64_SUB_RRR_I_32_4(int r0,int r1,int r2){ /* sub */
	aarch64_G32(((0x375 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRR_I_32_4\n", h2_asm_pc);
#endif
}
void A64_SUB_RRR_I_64_2(int r0,int r1,int r2){ /* sub */
	aarch64_G32(((0x377 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRR_I_64_2\n", h2_asm_pc);
#endif
}
void A64_SUB_RRI_I_64_1(int r0,int r1,int i0){ /* sub */
	aarch64_G32(((0x344 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRI_I_64_1\n", h2_asm_pc);
#endif
}
void A64_SUB_RRR_I_64_1(int r0,int r1,int r2){ /* sub */
	aarch64_G32(((0x658 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x0 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_SUB_RRR_I_64_1\n", h2_asm_pc);
#endif
}
void A64_MOV_RRR_I_8_8(int r0,int r1,int r2){ /* mv */
	aarch64_G32(((0x75 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x7 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MOV_RRR_I_8_8\n", h2_asm_pc);
#endif
}
void A64_MOV_RRR_I_16_8(int r0,int r1,int r2){ /* mv */
	aarch64_G32(((0x275 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x7 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MOV_RRR_I_16_8\n", h2_asm_pc);
#endif
}
void A64_MOV_RI_I_32_1(int r0,int i0){ /* mv */
	aarch64_G32(((0x294 & 0x7ff) << 21)|((i0 & 0xffff) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MOV_RI_I_32_1\n", h2_asm_pc);
#endif
}
void A64_MOV_RR_I_32_1(int r0,int r1){ /* mv */
	aarch64_G32(((0x44000 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MOV_RR_I_32_1\n", h2_asm_pc);
#endif
}
void A64_MOV_RR_I_32_2(int r0,int r1){ /* mv */
	aarch64_G32(((0x138207 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MOV_RR_I_32_2\n", h2_asm_pc);
#endif
}
void A64_MOVI_RI_I_32_2(int r0,int i0){ /* mv */
	aarch64_G32(((0x1e0188 & 0x1ffffff) << 7)|((i0 & 0x3) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MOVI_RI_I_32_2\n", h2_asm_pc);
#endif
}
void A64_DUP_RR_I_32_1(int r0,int r1){ /* mv */
	aarch64_G32(((0x178101 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_DUP_RR_I_32_1\n", h2_asm_pc);
#endif
}
void A64_DUP_RR_I_32_2(int r0,int r1){ /* mv */
	aarch64_G32(((0x38101 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_DUP_RR_I_32_2\n", h2_asm_pc);
#endif
}
void A64_MOV_RR_I_64_1(int r0,int r1){ /* mv */
	aarch64_G32(((0x244000 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MOV_RR_I_64_1\n", h2_asm_pc);
#endif
}
void A64_MOV_RI_I_64_1(int r0,int i0){ /* mv */
	aarch64_G32(((0x694 & 0x7ff) << 21)|((i0 & 0xffff) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MOV_RI_I_64_1\n", h2_asm_pc);
#endif
}
void A64_DUP_RR_I_64_2(int r0,int r1){ /* mv */
	aarch64_G32(((0x138201 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_DUP_RR_I_64_2\n", h2_asm_pc);
#endif
}
void A64_DUP_RR_I_64_1(int r0,int r1){ /* mv */
	aarch64_G32(((0x178201 & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_DUP_RR_I_64_1\n", h2_asm_pc);
#endif
}
void A64_LDRB_RRI_I_8_1(int r0,int r1,int i0){ /* r */
	aarch64_G32(((0xe5 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_LDRB_RRI_I_8_1\n", h2_asm_pc);
#endif
}
void A64_LDRH_RRI_I_16_1(int r0,int r1,int i0){ /* r */
	aarch64_G32(((0x1e5 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_LDRH_RRI_I_16_1\n", h2_asm_pc);
#endif
}
void A64_LDR_RRI_I_32_1(int r0,int r1,int i0){ /* r */
	aarch64_G32(((0x2e5 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_LDR_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void A64_LDP_RRI_I_32_2(int r0,int r1,int i0){ /* r */
	aarch64_G32(((0xb3 & 0x3ff) << 22)|((i0 & 0x7f) << 15)|((0x0 & 0x1f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_LDP_RRI_I_32_2\n", h2_asm_pc);
#endif
}
void A64_LD1_RR_I_32_4(int r0,int r1){ /* r */
	aarch64_G32(((0x13101e & 0x3fffff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_LD1_RR_I_32_4\n", h2_asm_pc);
#endif
}
void A64_LDR_RRR_I_64_1(int r0,int r1,int r2){ /* r */
	aarch64_G32(((0x7e3 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x36 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_LDR_RRR_I_64_1\n", h2_asm_pc);
#endif
}
void A64_ADD_RRR_I_8_8(int r0,int r1,int r2){ /* add */
	aarch64_G32(((0x71 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ADD_RRR_I_8_8\n", h2_asm_pc);
#endif
}
void A64_ADD_RRR_I_8_16(int r0,int r1,int r2){ /* add */
	aarch64_G32(((0x271 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ADD_RRR_I_8_16\n", h2_asm_pc);
#endif
}
void A64_ADD_RRR_I_16_4(int r0,int r1,int r2){ /* add */
	aarch64_G32(((0x73 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ADD_RRR_I_16_4\n", h2_asm_pc);
#endif
}
void A64_ADD_RRR_I_16_8(int r0,int r1,int r2){ /* add */
	aarch64_G32(((0x273 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ADD_RRR_I_16_8\n", h2_asm_pc);
#endif
}
void A64_ADD_RRR_I_32_2(int r0,int r1,int r2){ /* add */
	aarch64_G32(((0x75 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ADD_RRR_I_32_2\n", h2_asm_pc);
#endif
}
void A64_ADD_RRR_I_32_4(int r0,int r1,int r2){ /* add */
	aarch64_G32(((0x275 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ADD_RRR_I_32_4\n", h2_asm_pc);
#endif
}
void A64_ADD_RRR_I_64_2(int r0,int r1,int r2){ /* add */
	aarch64_G32(((0x277 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x21 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ADD_RRR_I_64_2\n", h2_asm_pc);
#endif
}
void A64_ADD_RRR_I_64_1(int r0,int r1,int r2){ /* add */
	aarch64_G32(((0x458 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x0 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ADD_RRR_I_64_1\n", h2_asm_pc);
#endif
}
void A64_ADD_RRI_I_64_1(int r0,int r1,int i0){ /* add */
	aarch64_G32(((0x244 & 0x3ff) << 22)|((i0 & 0xfff) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ADD_RRI_I_64_1\n", h2_asm_pc);
#endif
}
void A64_LSL_RRI_I_32_1(int r0,int r1,int i0){ /* sl */
	aarch64_G32(((0x14c & 0x3ff) << 22)|(((-i0 % 32 & 0x1F) & 0x3f) << 16)|(((31-i0) & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_LSL_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void A64_LSL_RRR_I_32_1(int r0,int r1,int r2){ /* sl */
	aarch64_G32(((0xd6 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x8 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_LSL_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void A64_LSL_RRI_I_64_1(int r0,int r1,int i0){ /* sl */
	aarch64_G32(((0x34d & 0x3ff) << 22)|(((-i0 % 64 & 0x1F) & 0x3f) << 16)|(((63-i0) & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_LSL_RRI_I_64_1\n", h2_asm_pc);
#endif
}
void A64_LSL_RRR_I_64_1(int r0,int r1,int r2){ /* sl */
	aarch64_G32(((0x4d6 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x8 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_LSL_RRR_I_64_1\n", h2_asm_pc);
#endif
}
void A64_MUL_RRR_I_8_8(int r0,int r1,int r2){ /* mul */
	aarch64_G32(((0x71 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MUL_RRR_I_8_8\n", h2_asm_pc);
#endif
}
void A64_MUL_RRR_I_8_16(int r0,int r1,int r2){ /* mul */
	aarch64_G32(((0x271 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MUL_RRR_I_8_16\n", h2_asm_pc);
#endif
}
void A64_MUL_RRR_I_16_4(int r0,int r1,int r2){ /* mul */
	aarch64_G32(((0x73 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MUL_RRR_I_16_4\n", h2_asm_pc);
#endif
}
void A64_MUL_RRR_I_16_8(int r0,int r1,int r2){ /* mul */
	aarch64_G32(((0x273 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MUL_RRR_I_16_8\n", h2_asm_pc);
#endif
}
void A64_MUL_RRR_I_32_4(int r0,int r1,int r2){ /* mul */
	aarch64_G32(((0x275 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MUL_RRR_I_32_4\n", h2_asm_pc);
#endif
}
void A64_MUL_RRR_I_32_1(int r0,int r1,int r2){ /* mul */
	aarch64_G32(((0xd8 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x1f & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MUL_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void A64_MUL_RRR_I_32_2(int r0,int r1,int r2){ /* mul */
	aarch64_G32(((0x75 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x27 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MUL_RRR_I_32_2\n", h2_asm_pc);
#endif
}
void A64_MUL_RRR_I_64_1(int r0,int r1,int r2){ /* mul */
	aarch64_G32(((0x4d8 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x1f & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_MUL_RRR_I_64_1\n", h2_asm_pc);
#endif
}
void A64_STRB_RRI_I_8_1(int r0,int r1,int i0){ /* w */
	aarch64_G32(((0x1c0 & 0x7ff) << 21)|((i0 & 0x1ff) << 12)|((0x1 & 0x3) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_STRB_RRI_I_8_1\n", h2_asm_pc);
#endif
}
void A64_STRH_RRI_I_16_1(int r0,int r1,int i0){ /* w */
	aarch64_G32(((0x3c0 & 0x7ff) << 21)|((i0 & 0x1ff) << 12)|((0x1 & 0x3) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_STRH_RRI_I_16_1\n", h2_asm_pc);
#endif
}
void A64_ST1_RRI_I_32_4(int r0,int r1,int i0){ /* w */
	aarch64_G32(((0x130 & 0x3ff) << 22)|((i0 & 0x3f) << 16)|((0x1e & 0x3f) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ST1_RRI_I_32_4\n", h2_asm_pc);
#endif
}
void A64_STR_RRI_I_32_1(int r0,int r1,int i0){ /* w */
	aarch64_G32(((0x5c0 & 0x7ff) << 21)|((i0 & 0x1ff) << 12)|((0x1 & 0x3) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_STR_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void A64_ST1_RR_I_32_4(int r0,int r1){ /* w */
	aarch64_G32(((0x13001e & 0x3fffff) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_ST1_RR_I_32_4\n", h2_asm_pc);
#endif
}
void A64_STR_RRR_I_32_1(int r0,int r1,int r2){ /* w */
	aarch64_G32(((0x5c1 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x36 & 0x3f) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_STR_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void A64_STR_RRI_I_32_2(int r0,int r1,int i0){ /* w */
	aarch64_G32(((0x7e0 & 0x7ff) << 21)|((i0 & 0x1ff) << 12)|((0x0 & 0x3) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_STR_RRI_I_32_2\n", h2_asm_pc);
#endif
}
void A64_STR_RRI_I_64_1(int r0,int r1,int i0){ /* w */
	aarch64_G32(((0x7c0 & 0x7ff) << 21)|((i0 & 0x1ff) << 12)|((0x1 & 0x3) << 10)|((r0 & 0x1f) << 5)|((r1 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_STR_RRI_I_64_1\n", h2_asm_pc);
#endif
}
void A64_STR_RRR_I_64_1(int r0,int r1,int r2){ /* w */
	aarch64_G32(((0x7c1 & 0x7ff) << 21)|((r2 & 0x1f) << 16)|((0x36 & 0x3f) << 10)|((r1 & 0x1f) << 5)|((r0 & 0x1f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : A64_STR_RRR_I_64_1\n", h2_asm_pc);
#endif
}

// Usefull macro instruction to simplify instruction selector code
#define isInt64_1(P)  ((P.arith == 'i') && (P.wLen <= 64) && (P.vLen == 1))
#define isInt32_1(P)  ((P.arith == 'i') && (P.wLen <= 32) && (P.vLen == 1))
#define isInt0(P)     ((P.arith == 'i') && (P.ValOrReg == VALUE) && (0 == P.valueImm))
#define isInt1(P)     ((P.arith == 'i') && (P.ValOrReg == VALUE) && (1 == P.valueImm))
#define isValue(P)    ((P.arith == 'i') && (P.ValOrReg == VALUE))
#define isReg32(P, X) ((P.arith == 'i') && (P.ValOrReg == REGISTER) && (X == P.regNro))
#define isRRR(P0, P1, P2) (P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
#define isRRV(P0, P1, P2) (P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
#define immValueZero (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(0)}
h2_sValue_t aarch64_genSL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genW_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genR_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genRET_0();
h2_sValue_t aarch64_genADD_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genMUL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genMV_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genSUB_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t aarch64_genSL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for SL instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for SL

// No specific optimisation for SL/aarch64

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LSL_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_LSL_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LSL_RRI_I_64_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_LSL_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, SL instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genW_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for W instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for W

/* -*- c -*- */

/* if (isInt32_1(P0) && isInt0(P1)  && isInt0(P2) ) */
/*   {  */
/*     #ifdef H2_DEBUG_INSN */
/*     // Store const 0 in memory (alias store, r31 interpreted as 0) */
/*     printf ("Store 0 (aarch64)\\n"); */
/*     #endif */
/*     A64_STR_RRI_I_32_1(P0.regNro, 31, 0); */
/*     return P0; */
/*   } */

if (isValue(P1))
  { // Store constant (Should use RRI variant)
	h2_sValue_t PTMP = {REGISTER, P1.arith, P1.vLen, P1.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RI W (aarch64)\\n");
    #endif
	// MV const in tmp register
	P1 = aarch64_genMV_3(PTMP,  P1, immValueZero);
	// No return continue instruction selection
  }

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_ST1_RR_I_32_4(P0.regNro, P1.regNro);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 8) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_STRB_RRI_I_8_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 16) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_STRH_RRI_I_16_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_ST1_RRI_I_32_4(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_STR_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_STR_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_STR_RRI_I_32_2(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 64) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_STR_RRI_I_64_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 64) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_STR_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P1;
    }
	printf ("Warning, W instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genR_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for R instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for R

// No specific optimisation for R/aarch64

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_LD1_RR_I_32_4(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LDRB_RRI_I_8_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LDRH_RRI_I_16_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LDR_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_LDP_RRI_I_32_2(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_LDR_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, R instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genRET_0()
{
// No generic optimisation for RET

// No specific optimisation for RET/aarch64

A64_RET__I_64_1();
	
}
h2_sValue_t aarch64_genADD_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for ADD instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
/* -*- c -*- */
if (isInt0 (P2))
  { // P0 = P1 + 0
    #ifdef H2_DEBUG_INSN
	printf ("Optim add for 0 (generic) return reg %d\n", P1.regNro);
    #endif
	return P1;
  }
if (isInt0 (P1))
  { // P0 = P2 + 0
    #ifdef H2_DEBUG_INSN
    printf ("Optim add for 0  (generic) return reg %d\n", P2.regNro);
    #endif
    return P2;
  }

// No specific optimisation for ADD/aarch64

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_8_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 16) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_8_16(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_16_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_16_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_32_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_32_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_64_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_ADD_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_ADD_RRI_I_64_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }
	printf ("Warning, ADD instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genMUL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for MUL instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
/* -*- c -*- */
  if (isInt0(P2) || isInt0(P1))
   {    // X * 0 = 0 Avoid 1 operation mul & 1 mv
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *0 P2 (generic)\n");
        #endif
        return immValueZero;
    }
  if (isInt1(P2))
    { // X * 1 = X propagate register result
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *1 P2 (generic)\n");
        #endif
        return P1;
    }
  if (isInt1(P1))
    { // 1 * X = X propagate register result
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *1 P1 (generic)\n");
        #endif
        return P2;
    }

/* -*- c -*- */
if  ((P1.ValOrReg == VALUE) && (P2.ValOrReg == REGISTER))
    { // Transform RIR in RRI : P1 & P2 permutation
       h2_sValue_t PTMP = P2;
       P2 = P1;
       P1 = PTMP; 
    }
if  ((P2.ValOrReg == VALUE) && (P2.arith == 'i') && ((P2.valueImm != 0) && !(P2.valueImm & (P2.valueImm - 1))))
  { // X * NPowerOf2 = X << N (immediate shift left)
	int shiftValue = h2_log2(P2.valueImm);
    #ifdef H2_DEBUG_INSN
      printf ("Optim for * %d (power of 2) -> sl %d (aarch64)\n", P2.valueImm, shiftValue);
    #endif
	// Instruction shift left immediat
	P2.valueImm = shiftValue;
	return aarch64_genSL_3(P0, P1, P2);
  }
if  ((P2.ValOrReg == VALUE) && (P2.arith == 'i'))
{
	h2_sValue_t PTMP = {REGISTER, P2.arith, P2.vLen, P2.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RRI mul (aarch64)\n");
    #endif
	P2 = aarch64_genMV_3(PTMP,  P2, immValueZero);
	// No return continue instruction selection
}

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_8_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 16) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_8_16(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_16_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_16_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_32_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_32_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MUL_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, MUL instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genMV_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for MV instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for MV

// No specific optimisation for MV/aarch64

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
	A64_MOV_RI_I_32_1(P0.regNro, P1.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_MOV_RR_I_32_1(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_MOV_RR_I_32_2(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
	A64_MOVI_RI_I_32_2(P0.regNro, P1.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_DUP_RR_I_32_1(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_DUP_RR_I_32_2(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_MOV_RR_I_64_1(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
	A64_MOV_RI_I_64_1(P0.regNro, P1.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_DUP_RR_I_64_2(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
	A64_DUP_RR_I_64_1(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MOV_RRR_I_8_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_MOV_RRR_I_16_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, MV instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t aarch64_genSUB_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for SUB instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for SUB

// No specific optimisation for SUB/aarch64

	if ((P0.ValOrReg == REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_8_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 16) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_8_16(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_16_8(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_16_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_SUB_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_32_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_32_4(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 2) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_64_2(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
	A64_SUB_RRI_I_64_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
	A64_SUB_RRR_I_64_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, SUB instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}

/* End Header autogenerated part */
/* -*- c -*- */
// https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/mesa/math/m_matrix.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <strings.h>
#define T 4
typedef int d_t;
typedef d_t matrix_t [T][T];
typedef d_t vector_t [T];
typedef d_t (*pifvv)(vector_t, vector_t);

pifvv genVectorMatrixProduct(pifvv ptr, matrix_t m)
{
	/* Code Generation of 5 instructions */
	/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t o = {REGISTER, 'i', 1, 32, 0, 0};
	h2_sValue_t i = {REGISTER, 'i', 1, 32, 1, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 1, 32, 0, 0};
	h2_sValue_t READ_i_0 = {REGISTER, 'i', 1, 32, 2, 0};
	h2_sValue_t READ_i_4 = {REGISTER, 'i', 1, 32, 3, 0};
	h2_sValue_t READ_i_8 = {REGISTER, 'i', 1, 32, 4, 0};
	h2_sValue_t READ_i_12 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t tmp0000 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0001 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0002 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0003 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0004 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0005 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0006 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0007 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0008 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0009 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0010 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0011 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0012 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0013 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0014 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0015 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0016 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0017 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0018 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0019 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0020 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0021 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0022 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0023 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0024 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0025 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0026 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0027 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0028 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0029 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0030 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0031 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0032 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0033 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0034 = {REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0035 = {REGISTER, 'i', 1, 32, -1, 0};

	/* Label  table :*/
/* No label table to avoid C warning for empty table ... */
	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = true;
	h2_start_codeGen = h2_getticks();
	h2_initRegisterMasks(0xFFFF013F, 0, 0, 0);
	h2_resetRegisterMasks();
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask initialization\n");
	#endif // H2_DEBUG_REGISTER
	tmp0000 = aarch64_genADD_3(tmp0000, o, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(0)});
	tmp0001 = aarch64_genADD_3(tmp0001, i, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(0)});
	READ_i_0 = aarch64_genR_3(READ_i_0, tmp0001, immValueZero);
	tmp0002 = aarch64_genMUL_3(tmp0002, tmp0001, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[0][0]))});
	tmp0003 = aarch64_genADD_3(tmp0003, i, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(4)});
	READ_i_4 = aarch64_genR_3(READ_i_4, tmp0003, immValueZero);
	tmp0004 = aarch64_genMUL_3(tmp0004, tmp0003, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[1][0]))});
	tmp0005 = aarch64_genADD_3(tmp0005, tmp0002, tmp0004);
	h2_freeReg(tmp0002.regNro);
	h2_freeReg(tmp0004.regNro);
	tmp0006 = aarch64_genADD_3(tmp0006, i, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(8)});
	READ_i_8 = aarch64_genR_3(READ_i_8, tmp0006, immValueZero);
	tmp0007 = aarch64_genMUL_3(tmp0007, tmp0006, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[2][0]))});
	tmp0008 = aarch64_genADD_3(tmp0008, tmp0005, tmp0007);
	h2_freeReg(tmp0005.regNro);
	h2_freeReg(tmp0007.regNro);
	tmp0009 = aarch64_genADD_3(tmp0009, i, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(12)});
	READ_i_12 = aarch64_genR_3(READ_i_12, tmp0009, immValueZero);
	tmp0010 = aarch64_genMUL_3(tmp0010, tmp0009, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[3][0]))});
	tmp0011 = aarch64_genADD_3(tmp0011, tmp0008, tmp0010);
	h2_freeReg(tmp0008.regNro);
	h2_freeReg(tmp0010.regNro);
	aarch64_genW_3(tmp0000, tmp0011, immValueZero);
	h2_freeReg(tmp0000.regNro);
	h2_freeReg(tmp0011.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0012 = aarch64_genADD_3(tmp0012, o, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(4)});
	tmp0013 = aarch64_genMUL_3(tmp0013, READ_i_0, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[0][1]))});
	tmp0014 = aarch64_genMUL_3(tmp0014, READ_i_4, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[1][1]))});
	tmp0015 = aarch64_genADD_3(tmp0015, tmp0013, tmp0014);
	h2_freeReg(tmp0013.regNro);
	h2_freeReg(tmp0014.regNro);
	tmp0016 = aarch64_genMUL_3(tmp0016, READ_i_8, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[2][1]))});
	tmp0017 = aarch64_genADD_3(tmp0017, tmp0015, tmp0016);
	h2_freeReg(tmp0015.regNro);
	h2_freeReg(tmp0016.regNro);
	tmp0018 = aarch64_genMUL_3(tmp0018, READ_i_12, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[3][1]))});
	tmp0019 = aarch64_genADD_3(tmp0019, tmp0017, tmp0018);
	h2_freeReg(tmp0017.regNro);
	h2_freeReg(tmp0018.regNro);
	aarch64_genW_3(tmp0012, tmp0019, immValueZero);
	h2_freeReg(tmp0012.regNro);
	h2_freeReg(tmp0019.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0020 = aarch64_genADD_3(tmp0020, o, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(8)});
	tmp0021 = aarch64_genMUL_3(tmp0021, READ_i_0, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[0][2]))});
	tmp0022 = aarch64_genMUL_3(tmp0022, READ_i_4, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[1][2]))});
	tmp0023 = aarch64_genADD_3(tmp0023, tmp0021, tmp0022);
	h2_freeReg(tmp0021.regNro);
	h2_freeReg(tmp0022.regNro);
	tmp0024 = aarch64_genMUL_3(tmp0024, READ_i_8, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[2][2]))});
	tmp0025 = aarch64_genADD_3(tmp0025, tmp0023, tmp0024);
	h2_freeReg(tmp0023.regNro);
	h2_freeReg(tmp0024.regNro);
	tmp0026 = aarch64_genMUL_3(tmp0026, READ_i_12, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[3][2]))});
	tmp0027 = aarch64_genADD_3(tmp0027, tmp0025, tmp0026);
	h2_freeReg(tmp0025.regNro);
	h2_freeReg(tmp0026.regNro);
	aarch64_genW_3(tmp0020, tmp0027, immValueZero);
	h2_freeReg(tmp0020.regNro);
	h2_freeReg(tmp0027.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	tmp0028 = aarch64_genADD_3(tmp0028, o, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(12)});
	tmp0029 = aarch64_genMUL_3(tmp0029, READ_i_0, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[0][3]))});
	tmp0030 = aarch64_genMUL_3(tmp0030, READ_i_4, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[1][3]))});
	tmp0031 = aarch64_genADD_3(tmp0031, tmp0029, tmp0030);
	h2_freeReg(tmp0029.regNro);
	h2_freeReg(tmp0030.regNro);
	tmp0032 = aarch64_genMUL_3(tmp0032, READ_i_8, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[2][3]))});
	tmp0033 = aarch64_genADD_3(tmp0033, tmp0031, tmp0032);
	h2_freeReg(tmp0031.regNro);
	h2_freeReg(tmp0032.regNro);
	tmp0034 = aarch64_genMUL_3(tmp0034, READ_i_12, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((m[3][3]))});
	tmp0035 = aarch64_genADD_3(tmp0035, tmp0033, tmp0034);
	h2_freeReg(tmp0033.regNro);
	h2_freeReg(tmp0034.regNro);
	aarch64_genW_3(tmp0028, tmp0035, immValueZero);
	h2_freeReg(tmp0028.regNro);
	h2_freeReg(tmp0035.regNro);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	aarch64_genRET_0();
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	h2_end_codeGen = h2_getticks();
	h2_iflush(ptr, h2_asm_pc);

  return ptr;
}

d_t VectorMatrixProductUnrolled (vector_t o, vector_t i, matrix_t m)
{
  o[0] = i[0]*m[0][0] + i[1]*m[1][0] + i[2]*m[2][0] + i[3]*m[3][0];
  o[1] = i[0]*m[0][1] + i[1]*m[1][1] + i[2]*m[2][1] + i[3]*m[3][1];
  o[2] = i[0]*m[0][2] + i[1]*m[1][2] + i[2]*m[2][2] + i[3]*m[3][2];
  o[3] = i[0]*m[0][3] + i[1]*m[1][3] + i[2]*m[2][3] + i[3]*m[3][3];
  return o[3];
}

d_t VectorMatrixProductUnrolledSR(vector_t o, vector_t i, matrix_t m)
{

  o[0] = m[0][0] * i[0] +                                 + m[3][0] * i[3];
  o[1] =                  m[1][1] * i[1] +                + m[3][1] * i[3];
  o[2] =                                   m[2][2] * i[2] + m[3][2] * i[3];
  o[3] =                                                  +           i[3];
  return o[3];
}

d_t VectorMatrixProduct (vector_t o, vector_t i, matrix_t m)
{
  for (int column = 0; column < T; column++)
    {
      o[column] = 0;
      // printf("o[%d] = ",column);
      for (int line = 0; line < T; line++)
        {
          o[column] += i[line] * m[line][column];
          //          printf("+ i[%d]*m[%d][%d]", line, line, column);
        }
      //      printf("\n");
    }
  //     printf("\n");
  return o[3];
}


int VectorMatrixProductCount(matrix_t mat)
{
  int op = 0;
  for (int column = 0; column < T; column++)
    {
      for (int line = 0; line < T; line++)
        {
          switch (mat[line][column])
            {
            case 0 : op += 0; break;
            case 1 : op += 1; break;
            default: op += 2; break;
            }
        }
    }
  return op;
}


void printMatrix (matrix_t m, char msg[])
{
  printf ("%s:\n", msg);
  for (int column = 0; column < T; column++)
    {
      for (int line = 0; line < T; line++)
        {
          printf ("%4d ", m[line][column]);
        }
      printf ("\n");
    }
  printf ("\n");
}

void printVector (vector_t v, char msg[])
{
  for (int i = 0; i < T; i++)
    printf ("%4d ", v[i]);
  printf ("%s\n", msg);
}

void vectorCompare(vector_t ref, vector_t other, char * msg, int doPrint)
{
  int has_differences = 0;
  for (int i = 0; i < T; i++)
    {
      if (ref[i] != other[i])
        has_differences = 1;
      if (doPrint)
        printf("%4d ", other[i]);
    }
  printf("%s : ", msg);
  printf(" %s\n", (has_differences)?"NOT OK":"OK");
}

int main (int argc, char *argv[])
{
  matrix_t m;
  char *matrixName;
  vector_t g0  = {1, 2, 3, 4}, g1  = {5, 6, 7, 8};
  vector_t tmp0, tmp1;
  vector_t utmp0, utmp1;
  vector_t ctmp0, ctmp1;
  uint64_t start, stop, general, compilette, unrolled;
  pifvv vmProduct;
  int tmp, doPrint, acc;

  if (argc != 18)
    {
      printf ("Not enough arguments %d\n", argc);
      printf ("VectorMatrix MatrixName M11 M12 ... M44\n");
      exit (-1);
    }
  doPrint = 1;
  acc = 0;
  matrixName = argv[1];
  for (int line = 0; line < 4; line++)
    for (int column = 0; column < 4; column++)
      {
        m[line][column] = atoi (argv[2 + line*4+column]);
      }
  printMatrix(m, matrixName);
  tmp = VectorMatrixProductCount (m);
  printf("Operation count Matrix %s : %d speedup %.1f\n", matrixName, tmp, 32.0/tmp);

#define DO(INSN, REPEAT, TIME) {start = h2_getticks();for (int i = 0; i < REPEAT; i++) INSN;  stop = h2_getticks(); TIME = stop - start;}

  printVector (g1, "Input  vector");
  acc += VectorMatrixProduct (tmp0, g0, m); /* Cold start */
  DO(acc += VectorMatrixProduct (tmp1, g1, m), 1000, general)
  printVector (tmp1, "Output vector   (general)");

  acc += VectorMatrixProductUnrolled (utmp0, g0, m);
  start = h2_getticks();
  DO(acc += VectorMatrixProductUnrolled (utmp1, g1, m), 1000, unrolled);
  vectorCompare(tmp1, utmp1, "Unrolled tmp0", doPrint);

  vmProduct = (pifvv) h2_malloc(1024);
  vmProduct = genVectorMatrixProduct (vmProduct, m);
  acc += vmProduct (ctmp0, g0);
  DO(acc += vmProduct (ctmp1, g1), 1000, compilette)

  vectorCompare(tmp1, ctmp1, "Compilette tmp1", doPrint);
  compilette = stop - start;

  printf ("General    ticks %lu\n", general);
  printf ("Unrolled   ticks %lu\n", unrolled);
  printf ("Compilette ticks %lu\n", compilette);
  printf ("Speedups unrolled   : %.2f%%\n", (float) 100.0*general/unrolled);
  printf ("Speedups compilette : %.2f%%\n", (float) 100.0*general/compilette);
  printf ("Accumulator value to avoid hard optimizations %d\n", acc);
  return 0;
}
