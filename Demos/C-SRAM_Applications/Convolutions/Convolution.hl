// -*- c -*-

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "csram_utils.h"

//choose the data you want to use 
#include "TensorConv.h"
// #include "TensorConvLong.h"
// #include "TensorConvPad.h"
// #include "TensorConvStride.h"

int main(int argc, char *argv[])
{
	mmap_qemu_counters();
	*to_counter = 1;
	int resultOK;
	OutputMac output;

	output.dims[0] = outputRef.dims[0];
	output.dims[1] = outputRef.dims[1];
	output.dims[2] = outputRef.dims[2];
	output.dims[3] = outputRef.dims[3];
	const int batches = input.dims[0]; // et output(0)
	const int input_height = input.dims[1];
	const int input_width = input.dims[2];
	const int input_depth = input.dims[3];
	const int filter_height = filter.dims[1];
	const int filter_width = filter.dims[2];
	const int filter_input_depth = filter.dims[3];
	const int output_height = output.dims[1];
	const int output_width = output.dims[2];
	const int output_depth = output.dims[3]; // et filter(0)

	// parametres de convolutions
	const int input_offset = params.input_offset;
	const int pad_width = params.pad_width;
	const int pad_height = params.pad_height;
	const int stride_width = params.stride_width;
	const int stride_height = params.stride_height;
	const int dilation_width_factor = params.dilation_width;
	const int dilation_height_factor = params.dilation_height;

	for (int batch = 0; batch < batches; ++batch)
	{
		for (int out_y = 0; out_y < output_height; ++out_y)
		{
			const int in_y_origin = (out_y * stride_height) - pad_height;
			for (int out_x = 0; out_x < output_width; ++out_x)
			{
				const int in_x_origin = (out_x * stride_width) - pad_width;
				for (int out_channel = 0; out_channel < output_depth; ++out_channel)
				{
					// auto group = out_channel / filters_per_group;
					int acc = 0;
					for (int filter_y = 0; filter_y < filter_height; ++filter_y)
					{
						const int in_y = in_y_origin + dilation_height_factor * filter_y;
						for (int filter_x = 0; filter_x < filter_width; ++filter_x)
						{
							const int in_x = in_x_origin + dilation_width_factor * filter_x;

							// Zero padding by omitting the areas outside the image.
							const int is_point_inside_image =
									(in_x >= 0) && (in_x < input_width) && (in_y >= 0) &&
									(in_y < input_height);

							if (!is_point_inside_image)
							{
								continue;
							}

							for (int in_channel = 0; in_channel < filter_input_depth;
									 ++in_channel)
							{
								int32_t input_val = input.data[((batch * input.dims[1] + in_y)
																							 * input.dims[2] + in_x) * input.dims[3] + in_channel];
								int32_t filter_val = filter.data[((out_channel * filter.dims[1] + filter_y)
																							 * filter.dims[2] + filter_x) * filter.dims[3] + in_channel];
								acc += filter_val * (input_val + input_offset);
							}
						}
					}
					output.data[((batch * output.dims[1] + out_y) * output.dims[2] + out_x) * output.dims[3] + out_channel] = acc;
				}
			}
		}
	}
	*to_counter = 0;

	// test du rÃ©sutat de la convolution
	resultOK = 0;
	for (int i = 0; i < (batches * output_height * output_width * output_depth); i++)
	{
		if (output.data[i] != outputRefMac.data[i])
		{
			resultOK = -1;
			printf("output_data[%d] = %d, outputRef_data[%d] = %d\n", i, output.data[i], i, outputRefMac.data[i]);
			printf("Erreur MAC\n");
			break;
		}
	}
	if (resultOK == 0)
		printf("Convolution OK\n");
	return resultOK;
}
// rajouter la quntisation et la fontion d'activation