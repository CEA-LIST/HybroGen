#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <fft_utils.h>
#include <sine.h>


void BitReverseCopy(cplx_t *Input, cplx_t *Output, uint32_t length, uint32_t *bit_reverse)
{
	int i;
	for(i = 0; i < length; i += 1)
	{
		Output[bit_reverse[i]] = Input[i];
	}
}

// Cooley-Tukey FFT algorithm, four-step version, performs data re-ordering
// using bit reversal and in-place computation to limit the memory
// footprint (see Wikipedia page https://w.wiki/ps8 for more information)
void FastFourierTransform(cplx_t *Input, cplx_t *Output, uint32_t length, uint32_t *bit_reverse)
{
	BitReverseCopy(Input, Output, length, bit_reverse);
	for (uint32_t s = 1; s <= (uint32_t)log2(length); s += 1)
	{
		uint32_t m = 1 << s;
		cplx_t w_m = twiddle(s);

		for (uint32_t k = 0; k < length; k += m)
		{
			#if defined(CPLX32) || defined(CPLX16)
			cplx_t w = cplx_new(flt_to_fixed(1), 0);
			#else
			cplx_t w = cplx_new(1, 0);
			#endif
			for (uint32_t j = 0; j < m/2; j += 1)
			{
				cplx_t t = cplx_mul(w, Output[k + j + m/2]);
				cplx_t u = Output[k + j];
				Output[k + j] = cplx_add(u, t);
				Output[k + j + m/2] = cplx_sub(u, t);
				w = cplx_mul(w, w_m);
			}
		}
	}
}

int main(int argc, char **argv)
{
	if (argc != 3)
	{
		printf("USAGE : ./DFT [input.sine] [output.dft]\n");
		exit(1);
	}
	int i, j;
	char *filename = argv[1];

	/*** Original version for reference ***/
	printf("Loading input in 1D sine...\n");
	Sine1D *X_ref = ReadInputSine1D(filename);
	printf("Allocating 1D output sine...\n");
	Sine1D *Y_ref = CreateSine1D(X_ref->length);

	printf("Computing ref. FFT...\n");
	FastFourierTransform(X_ref->data, Y_ref->data, X_ref->length, bit_reverse_);
	printf("done.\n");

	/*** New version (Transpose-Split) ***/
	printf("Loading input in 2D sine...\n");

	Sine2D *X = ReadInputSine2D(filename);
	Sine2D *X1 = X;
	Sine2D *X2 = CreateSine2D_2(X1);
	for(i = 0; i < X2->height; i += 1)
	{
		cplx_t *X1_ = &(X1->data[i * X1->width]);
		cplx_t *X2_ = &(X2->data[i * X2->width]);
		FastFourierTransform(X1_, X2_, X1->width, bit_reverse_1_);
		for(j = 0; j <X2->width; j += 1)
		{
			cplx_t w = twiddle2((i+1) * (j+1));
			printf("twiddle2(%dx%d/%d) = %s\n", (i+1),(j+1), X2->width * X2->height, cplx_str_flt(w));
			X2_[j] = cplx_mul(X2_[j], w);
		}
	}
	Sine2D *X3 = TransposeSine2D(X2);
	Sine2D *Y  = CreateSine2D_2(X3);
	for(i = 0; i < X3->height; i += 1)
	{
		cplx_t *X3_ = &(X3->data[i * X3->width]);
		cplx_t *Y_ = &(Y->data[i * Y->width]);
		FastFourierTransform(X3_, Y_, X3->width, bit_reverse_2_);
	}
	printf("Reference result :\n");
	PrintSine1D(Y_ref, PRINT_AS_FLOAT);
	printf("4-step result :\n");
	PrintSine2D(Y, PRINT_AS_FLOAT);

	return EXIT_SUCCESS;
}
