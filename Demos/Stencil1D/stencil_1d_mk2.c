/* Begin Header autogenerated part */
#ifndef H2_COMMON
#define H2_COMMON
/* Common HybroGen inserted code */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdint.h>

bool h2_codeGenerationOK;	 // Does code generation fail ?
typedef int32_t h2_regSet_t; // Register set (signed, use -1 when not allocated)
typedef unsigned long long ticks_t;
static  ticks_t h2_start_codeGen, h2_end_codeGen;

typedef enum { H2REGISTER,    H2VALUE, } VALORREG;
typedef struct
{
  int ValOrReg; // is H2REGISTER or immediate VALUE ?
  char arith;   // int, flt or other arithmetic
  int vLen;     // vector len
  int wLen;     // word len
  int regNro;   // register number (if register)
  int valueImm; // immediate value (if not register)
  bool dontFree; // if register, don't free
} h2_sValue_t;
#define sValueDef(VALUE, ARITH, VECTORLEN, WORDLEN, REGNO, IMMVAL) ((h2_sValue_t){.ValOrReg = VALUE, .arith = ARITH, .vLen = VECTORLEN, .wLen = WORDLEN, .regNro = REGNO, .valueImm = IMMVAL})
#define intsValue(V) sValueDef(H2VALUE, 'i', 1, 32, -1, V)
#define immValueZero intsValue(0)
// Usefull macro instruction to simplify instruction selector code
#define isInt64_1(P)  ((P.arith == 'i') && (P.wLen <= 64) && (P.vLen == 1))
#define isInt32_1(P)  ((P.arith == 'i') && (P.wLen <= 32) && (P.vLen == 1))
#define isInt0(P)     ((P.arith == 'i') && (P.ValOrReg == H2VALUE) && (0 == P.valueImm))
#define isInt1(P)     ((P.arith == 'i') && (P.ValOrReg == H2VALUE) && (1 == P.valueImm))
#define isValue(P)    ((P.arith == 'i') && (P.ValOrReg == H2VALUE))
#define isReg32(P, X) ((P.arith == 'i') && (P.ValOrReg == H2REGISTER) && (X == P.regNro))
#define isRRR(P0, P1, P2) (P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2REGISTER)
#define isRRV(P0, P1, P2) (P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)


typedef union {
    float f;
    unsigned long i;
} h2_float_int_u;

static int h2_log2(int value)
{ // integer logarithm
  int log = 0;
  while (value >>= 1) { ++log; }
  return log;
}

void printRev (int value, int pos)
{ // Print a bitset in reversal order (recursive)
  if (pos != 0)
	printRev (value >> 1, pos - 1);
  printf ("%1c", (value % 2)?'.':'F');
}

// Dynamic register allocation handling
// h2_regSet mask : 0 mean free register, 1 register set
//  3           2            1  Bit position = reg Number
// 1098 7654 3210 9876 5432 1098 7654 3210
// 1111 1111 1111 1111 0000 0001 0011 1111
typedef struct
{	// Register allocation sets for
  	// int, float, vector of ints, vector of floats
  int intSet, fltSet, vintSet, vfltSet ;
} h2_RegSets_t;

h2_RegSets_t h2_regSet, h2_regSetInit;

// Print integer register set
void printRegState(char * msg, int regNo, int registerSet)
{
  int count = 8 * sizeof (registerSet) - 1;
  h2_regSet_t tmpReg = registerSet;
  printf ("%02d : Reg %s\n", regNo, msg);
  for (int i = count; i >= 0; i--) // Tens
	(0 == (i % 10))?printf ("%d", i/10):printf (" ");
  printf ("\n");
  for (int i = count; i >= 0; i--) // Unit
	  printf ("%d", i%10);
  printf ("\n");
  printRev (tmpReg, count); // Bit set
  printf ("\n");
}

// Initialize registers sets allocation
static void h2_initRegisterMasks(int intmask, int fltmask, int vectorintmask, int vectorfltmask)
{ // See H2SymbolTable & H2RegisterBank
  h2_regSetInit.intSet  = intmask;
  h2_regSetInit.fltSet  = fltmask;
  h2_regSetInit.vintSet = vectorintmask;
  h2_regSetInit.vfltSet = vectorfltmask;
}

static void h2_resetRegisterMasks() // Reset register set from initializers
{
  h2_regSet.intSet  = h2_regSetInit.intSet;
  h2_regSet.fltSet  = h2_regSetInit.fltSet;
  h2_regSet.vintSet = h2_regSetInit.vintSet;
  h2_regSet.vfltSet = h2_regSetInit.vfltSet;
#ifdef H2_DEBUG_REGISTER
  printRegState("RESET", -1, h2_regSet.intSet);
#endif // H2_DEBUG_REGISTER
}
int h2_getReg () // Get new register
{
  /* Search for the 1st free register */
  h2_regSet_t tmpReg = h2_regSet.intSet;
  for (int i = 0; i < 8 * sizeof (h2_regSet.intSet); i++)
	{
	  if (tmpReg % 2 == 0)
		{						/* Free register found */
		  h2_regSet.intSet = h2_regSet.intSet | (1 << i); /* Update regSet */
#ifdef H2_DEBUG_REGISTER
		  printRegState("GET", i, h2_regSet.intSet);
#endif // H2_DEBUG_REGISTER
		  return i;
		}
	  tmpReg >>= 1;
	}
  printf ("Register allocation failed\n");
  h2_codeGenerationOK = false;
  return -1;
}

// h2_regSet_t regToBeFreed[32];

void h2_freeReg (h2_regSet_t v) // Free a register
{
#if 1 // TODO : To be rethinked
      // Is the register freeable ?
  int isOK = (h2_regSetInit.intSet >> v) & 1;
  if (0 == isOK)
    {
	h2_regSet.intSet = h2_regSet.intSet & ~(1 << v); /* Update regSet */
#ifdef H2_DEBUG_REGISTER
    printRegState("FREE", v, h2_regSet.intSet);
#endif // H2_DEBUG_REGISTER
    }
#endif
}
#endif /*H2_COMMON*/
#ifndef H2_RISCV_RV32G
#define H2_RISCV_RV32G

#define H2SYS 					/* Has  operating system */

#include <stdint.h>
#ifdef H2SYS
#include <sys/mman.h>
#endif

typedef uint32_t    h2_insn_t;
static  h2_insn_t   *h2_asm_pc;
static  h2_insn_t    *h2_save_asm_pc;
static int h2_riscvVectorLen = 1;
static int h2_riscvVectorWidth = 1;
/*
https://stackoverflow.com/questions/52187221/how-to-calculate-the-no-of-clock-cycles-in-riscv-clang
*/

ticks_t h2_getticks(void)
{
    unsigned long dst;
    // output into any register, likely a0
    // regular instruction:
    asm volatile ("csrrs %0, 0xc00, x0" : "=r" (dst) );
    // regular instruction with symbolic csr and register names
    // asm volatile ("csrrs %0, cycle, zero" : "=r" (dst) );
    // pseudo-instruction:
    // asm volatile ("csrr %0, cycle" : "=r" (dst) );
    // pseudo-instruction:
    //asm volatile ("rdcycle %0" : "=r" (dst) );
    return dst;
}


static void h2_iflush(void *addr, void *last)
{
#ifdef H2SYS
    long pageSize= getpagesize();
    void *ptmp= (char *)((long)addr & ~(pageSize - 1));
    if (mprotect(ptmp, (last - addr), PROT_READ | PROT_WRITE | PROT_EXEC))
    {
        perror("iflush: mprotect");
        exit(-1);
    }
    __clear_cache((char *)addr, (char *)last);
#endif
#ifdef H2_DEBUG
	uint64_t codeGenDuration = h2_end_codeGen - h2_start_codeGen;
	uint64_t insnGenerated = (last-addr)/sizeof (h2_insn_t);
    printf ("Flush data cache from %p to %p\n", addr, last);
	printf ("%lld insn generated in %lld ticks. %lld ticks / insn\n", insnGenerated, codeGenDuration, codeGenDuration/insnGenerated);
#endif
	if (!h2_codeGenerationOK)
	  {
		fprintf (stderr, "(iflush) Failed code generation\n");
		exit(-5);
	  }
}

static h2_insn_t *h2_malloc (size_t size)
{
  return malloc (size);
}


#endif /*H2_RISCV_RV32G*/
/* In memory instruction generator */
#define riscv_G32(INSN){ *(h2_asm_pc++) = (INSN);}

/* Single instruction binary code generator*/
void RV32I_RET__I_32_1(){ /* RET */
	riscv_G32(((0x8067 >> 0) & 0xffffffff)); \

#ifdef H2_DEBUG_INSN
printf("%p : RV32I_RET__I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_MV_RR_I_32_1(int r0,int r1){ /* MV */
	riscv_G32(((0x0 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r0 & 0x1f) << 7)|((0x13 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_MV_RR_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_MV_RI_I_32_1(int r3,int i1){ /* MV */
	riscv_G32(((i1 & 0xfff) << 20)|((0x6 & 0xff) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_MV_RI_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_SLLI_RRI_I_32_1(int r3,int r1,int i0){ /* SL */
	riscv_G32(((0x0 & 0x7f) << 25)|((i0 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SLLI_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_SLL_RRR_I_32_1(int r3,int r1,int r2){ /* SL */
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SLL_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void RV32M_MUL_RRR_I_32_1(int r3,int r1,int r2){ /* MUL */
	riscv_G32(((0x1 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32M_MUL_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_SB_RRI_I_8_1(int r1,int r2,int i1){ /* W */
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SB_RRI_I_8_1\n", h2_asm_pc);
#endif
}
void RV32I_SH_RRI_I_16_1(int r1,int r2,int i1){ /* W */
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SH_RRI_I_16_1\n", h2_asm_pc);
#endif
}
void RV32I_SW_RRI_I_32_1(int r1,int r2,int i1){ /* W */
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x2 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SW_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_SUB_RRR_I_32_1(int r3,int r1,int r2){ /* SUB */
	riscv_G32(((0x20 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_SUB_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_ADDI_RRI_I_32_1(int r1,int r0,int i0){ /* ADD */
	riscv_G32(((i0 & 0xfff) << 20)|((r0 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r1 & 0x1f) << 7)|((0x13 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_ADDI_RRI_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_ADD_RRR_I_32_1(int r3,int r1,int r2){ /* ADD */
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_ADD_RRR_I_32_1\n", h2_asm_pc);
#endif
}
void RV32I_LB_RRI_I_8_1(int r3,int r1,int i1){ /* R */
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x3 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_LB_RRI_I_8_1\n", h2_asm_pc);
#endif
}
void RV32I_LH_RRI_I_16_1(int r3,int r1,int i1){ /* R */
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x3 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_LH_RRI_I_16_1\n", h2_asm_pc);
#endif
}
void RV32I_LW_RRI_I_32_1(int r3,int r1,int i1){ /* R */
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x2 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x3 & 0x7f) >> 0));
#ifdef H2_DEBUG_INSN
printf("%p : RV32I_LW_RRI_I_32_1\n", h2_asm_pc);
#endif
}
h2_sValue_t riscv_genSUB_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t riscv_genR_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t riscv_genMUL_4(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2,h2_sValue_t P3);
h2_sValue_t riscv_genMV_2(h2_sValue_t P0,h2_sValue_t P1);
h2_sValue_t riscv_genSL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t riscv_genW_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t riscv_genRET_0();
h2_sValue_t riscv_genADD_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2);
h2_sValue_t riscv_genSUB_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for SUB instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
/* -*- c -*- */
// if 2 operands are constants do substraction evaluation (Thanks Kilian for the bug report)
if  ((P2.ValOrReg == H2VALUE) && (P1.ValOrReg == H2VALUE) && (P1.arith == 'i')&& (P2.arith == 'i'))
{
  return (h2_sValue_t) {H2VALUE, P1.arith, P1.vLen, P1.wLen, -1, P1.valueImm - P2.valueImm };
}

/* -*- c -*- */
if  ((P2.ValOrReg == H2VALUE) && (P2.arith == 'i'))
{
	h2_sValue_t PTMP = {H2REGISTER, P2.arith, P2.vLen, P2.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RRI sub (riscv)\\n");
    #endif
	P2 = riscv_genMV_2(PTMP,  P2);
}

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2REGISTER)
    {
	RV32I_SUB_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, SUB instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genR_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for R instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for R

// No specific optimisation for R/riscv

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_LB_RRI_I_8_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_LH_RRI_I_16_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_LW_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }
	printf ("Warning, R instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genMUL_4(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2,h2_sValue_t P3)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for MUL instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
/* -*- c -*- */
  // if 2 operands are constants do multiplication evaluation (Thanks Kilian for the bug report)
  if  ((P2.ValOrReg == H2VALUE) && (P1.ValOrReg == H2VALUE) && (P1.arith == 'i')&& (P2.arith == 'i'))
  {
    return (h2_sValue_t) {H2VALUE, P1.arith, P1.vLen, P1.wLen, -1, P1.valueImm * P2.valueImm };
  }
  if (isInt0(P2) || isInt0(P1))
   {    // X * 0 = 0 Avoid 1 operation mul & 1 mv
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *0 P2 (generic)\n");
        #endif
        return immValueZero;
    }
  if (isInt1(P2))
    { // X * 1 = X propagate register result
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *1 P2 (generic)\n");
        #endif
		P1.dontFree = true;
        return P1;
    }
  if (isInt1(P1))
    { // 1 * X = X propagate register result
        #ifdef H2_DEBUG_INSN
        printf ("Optim for *1 P1 (generic)\n");
        #endif
		P2.dontFree = true;
        return P2;
    }

/* -*- c -*- */
if  ((P2.ValOrReg == H2VALUE) && (P2.arith == 'i'))
{
	h2_sValue_t PTMP = {H2REGISTER, P2.arith, P2.vLen, P2.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RRI mul (aarch64)\n");
    #endif
	P2 = riscv_genMV_2(PTMP,  P2);
	// No return continue instruction selection
}

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2REGISTER)
    {
	RV32M_MUL_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, MUL instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genMV_2(h2_sValue_t P0,h2_sValue_t P1)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for MV instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for MV

// No specific optimisation for MV/riscv

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER)
    {
	RV32I_MV_RR_I_32_1(P0.regNro, P1.regNro);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2VALUE)
    {
	RV32I_MV_RI_I_32_1(P0.regNro, P1.valueImm);
	return P0;
    }
	printf ("Warning, MV instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genSL_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for SL instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for SL

// No specific optimisation for SL/riscv

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_SLLI_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2REGISTER)
    {
	RV32I_SLL_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, SL instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genW_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for W instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

#endif // H2_DEBUG_INSN
// No generic optimisation for W

/* -*- c -*- */
if (isValue(P1))
  { // Store constant (Should use RRI variant)
	h2_sValue_t PTMP = {H2REGISTER, P1.arith, P1.vLen, P1.wLen, h2_getReg()};
    #ifdef H2_DEBUG_INSN
      printf ("Fallback for no RI W (riscv)\\n");
    #endif
	// MV const in tmp register
	P1 = riscv_genMV_2(PTMP,  P1);
	// No return continue instruction selection
  }

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P1.arith == 'i') && (P1.wLen <= 8) && (P1.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_SB_RRI_I_8_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 16) && (P1.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_SH_RRI_I_16_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }

    if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_SW_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P1;
    }
	printf ("Warning, W instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
return immValueZero;
}
h2_sValue_t riscv_genRET_0()
{
// No generic optimisation for RET

// No specific optimisation for RET/riscv

RV32I_RET__I_32_1();
	
}
h2_sValue_t riscv_genADD_3(h2_sValue_t P0,h2_sValue_t P1,h2_sValue_t P2)
{
#ifdef H2_DEBUG_INSN
printf ("Start code gen for ADD instruction\n");

	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");

	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);

	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);

#endif // H2_DEBUG_INSN
/* -*- c -*- */
// If 2 operands are constants do addition
if  ((P2.ValOrReg == H2VALUE) && (P1.ValOrReg == H2VALUE) && (P1.arith == 'i')&& (P2.arith == 'i'))
{
  return sValueDef(H2VALUE, P1.arith, P1.vLen, P1.wLen, -1, P1.valueImm + P2.valueImm );
}
if (isInt0 (P2))
  { // P0 = P1 + 0
    #ifdef H2_DEBUG_INSN
	printf ("Optim add for 0 (generic) return reg %d\n", P1.regNro);
    #endif
	P1.dontFree = true;
	return P1;
  }
if (isInt0 (P1))
  { // P0 = 0 + P2
    #ifdef H2_DEBUG_INSN
    printf ("Optim add for 0  (generic) return reg %d\n", P2.regNro);
    #endif
	P2.dontFree = true;
    return P2;
  }

// No specific optimisation for ADD/riscv

	if ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))
		P0.regNro = h2_getReg();
	if ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))
		P1.regNro = h2_getReg();

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2VALUE)
    {
	RV32I_ADDI_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
	return P0;
    }

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == H2REGISTER && P1.ValOrReg == H2REGISTER && P2.ValOrReg == H2REGISTER)
    {
	RV32I_ADD_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
	return P0;
    }
	printf ("Warning, ADD instruction generation failed\n");
	h2_codeGenerationOK = false;
	printf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\n");
	printf ("P%d: %s/%c/%d/%d/%d\n", 0, (0==P0.ValOrReg)?"REG":"VAL", P0.arith, P0.wLen, P0.vLen, P0.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 1, (0==P1.ValOrReg)?"REG":"VAL", P1.arith, P1.wLen, P1.vLen, P1.valueImm);
	printf ("P%d: %s/%c/%d/%d/%d\n", 2, (0==P2.ValOrReg)?"REG":"VAL", P2.arith, P2.wLen, P2.vLen, P2.valueImm);
return immValueZero;
}

/* End Header autogenerated part */
// -*- c -*-
#include <stdio.h>
#include <stdlib.h>

typedef  int (*pifi)(int *, int *, int);

pifi genStencil(pifi ptr, int s1, int s2, int s3, int len)
{
	/* Code Generation of 2 instructions */
	/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t in = {H2REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t out = {H2REGISTER, 'i', 1, 32, 11, 0};
	h2_sValue_t i = {H2REGISTER, 'i', 1, 32, 12, 0};
	h2_sValue_t h2_outputVarName = {H2REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t tmp0000 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0001 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0002 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0003 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0004 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0005 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0006 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0007 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0008 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0009 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0010 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0011 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0012 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0013 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0014 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0015 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0016 = {H2REGISTER, 'i', 1, 32, -1, 0};
	h2_sValue_t tmp0017 = {H2REGISTER, 'i', 1, 32, -1, 0};

	/* Label  table :*/
/* No label table to avoid C warning for empty table ... */
	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = true;
	h2_start_codeGen = h2_getticks();
	h2_initRegisterMasks(0x1F1F, 0, 0, 0);
	h2_resetRegisterMasks();
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask initialization\n");
	#endif // H2_DEBUG_REGISTER
			tmp0000 = riscv_genMUL_4(tmp0000, i, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)}, immValueZero);
		tmp0001 = riscv_genADD_3(tmp0001, out, tmp0000);
		if (!tmp0001.dontFree) h2_freeReg(tmp0000.regNro);
								tmp0002 = riscv_genSUB_3(tmp0002, i, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)(1)});
							tmp0003 = riscv_genMUL_4(tmp0003, tmp0002, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)}, immValueZero);
							if (!tmp0003.dontFree) h2_freeReg(tmp0002.regNro);
						tmp0004 = riscv_genADD_3(tmp0004, in, tmp0003);
						if (!tmp0004.dontFree) h2_freeReg(tmp0003.regNro);
					tmp0005 = riscv_genR_3(tmp0005, tmp0004, immValueZero);
				tmp0006 = riscv_genMUL_4(tmp0006, tmp0005, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((s1))}, immValueZero);
				if (!tmp0006.dontFree) h2_freeReg(tmp0005.regNro);
							tmp0007 = riscv_genMUL_4(tmp0007, i, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)}, immValueZero);
						tmp0008 = riscv_genADD_3(tmp0008, in, tmp0007);
						if (!tmp0008.dontFree) h2_freeReg(tmp0007.regNro);
					tmp0009 = riscv_genR_3(tmp0009, tmp0008, immValueZero);
				tmp0010 = riscv_genMUL_4(tmp0010, tmp0009, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((s2))}, immValueZero);
				if (!tmp0010.dontFree) h2_freeReg(tmp0009.regNro);
			tmp0011 = riscv_genADD_3(tmp0011, tmp0006, tmp0010);
			if (!tmp0011.dontFree) h2_freeReg(tmp0006.regNro);
			if (!tmp0011.dontFree) h2_freeReg(tmp0010.regNro);
							tmp0012 = riscv_genADD_3(tmp0012, i, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)(1)});
						tmp0013 = riscv_genMUL_4(tmp0013, tmp0012, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((1 * 32) / 8)}, immValueZero);
						if (!tmp0013.dontFree) h2_freeReg(tmp0012.regNro);
					tmp0014 = riscv_genADD_3(tmp0014, in, tmp0013);
					if (!tmp0014.dontFree) h2_freeReg(tmp0013.regNro);
				tmp0015 = riscv_genR_3(tmp0015, tmp0014, immValueZero);
			tmp0016 = riscv_genMUL_4(tmp0016, tmp0015, (h2_sValue_t) {H2VALUE, 'i', 1, 32, 0, (int)((s3))}, immValueZero);
			if (!tmp0016.dontFree) h2_freeReg(tmp0015.regNro);
		tmp0017 = riscv_genADD_3(tmp0017, tmp0011, tmp0016);
		if (!tmp0017.dontFree) h2_freeReg(tmp0011.regNro);
		if (!tmp0017.dontFree) h2_freeReg(tmp0016.regNro);
	riscv_genW_3(tmp0001, tmp0017, immValueZero);
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	riscv_genRET_0();
	#ifdef H2_DEBUG_REGISTER
	printf("Tmp registers mask reset\n");
	#endif // H2_DEBUG_REGISTER
	h2_resetRegisterMasks();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	h2_end_codeGen = h2_getticks();
	h2_iflush(ptr, h2_asm_pc);

  return ptr;
}

void printArray(char * msg, int * array, int len)
{
  printf ("%15s (%3d) : ", msg, len);
  for (int i = 0; i < len; i++)
    printf ("%d ", array[i]);
  printf ("\n");
}


int main(int argc, char * argv[])
{
  int arrayLen, i, resultOK;
  pifi fPtr;
  int *arrayIn, *arrayOut;
  int stencil[3];
  int testval, stenLen = 3;

  if (argc < 5)
    {
      printf("Give 4 values (array len & 3 stencil coefficient)\n");
      exit(-1);
    }
  arrayLen = atoi (argv[1]);   // Get the array len
  stenLen = 3;
  arrayIn =  calloc (arrayLen, sizeof (int));
  arrayOut = calloc(arrayLen, sizeof (int));
  for (i=0; i<stenLen; i++)
    {
      stencil[i] = atoi(argv[i+2]);
    }
  for (i = 0; i < arrayLen; i++)
	{
      arrayIn[i]  = random () % 100;
	  arrayOut[i] = 0;
	}
  printArray ("arrayIn", arrayIn, arrayLen);
  printArray ("stencil", stencil, stenLen);

  fPtr = (pifi) genStencil (h2_malloc (1024), stencil[0], stencil[1], stencil[2], arrayLen);
  printf("IN             Compilette C\n");
  for (i=1; i<arrayLen-1; i++)
    {
      fPtr(arrayIn, arrayOut, i);  // Call generated code
      testval = arrayIn[i-1]*stencil[0] + arrayIn[i]*stencil[1] +  arrayIn[i+1]*stencil[2];
      printf("%4d, %4d, %4d, %4d, %4d : %s\n",
             arrayIn[i-1],
             arrayIn[i],
             arrayIn[i+1],
             arrayOut[i], testval, (testval != arrayOut[i])?"NOK":"OK");
    }
  printArray ("arrayOut", arrayOut, arrayLen);
  resultOK = 0;
  return resultOK;
}
