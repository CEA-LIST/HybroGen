#!/usr/bin/env python3

import sys, os
from HybroGen.IsaDb  import IsaDb
from HybroGen.Insn import Insn
from HybroGen.ProxyDb import *

class GenGeneratorFromDb:

    def __init__(self, archName, extList, abi, dbConf, verbose = False, debug = False):
        self.db = ProxyDb(dbConf["host"], dbConf["dbname"], dbConf["user"], dbConf["pwd"])
        self.isa = IsaDb(self.db, archName, extList)
        self.insnLenList = self.isa.getWordSizeFromDb()
        self.insnLenList.sort()
        self.archname = archName
        self.debug = debug
        self.verbose = verbose
        self.extList = extList
        self.abi = abi

    def Trace(self, msg):
        if self.verbose:
            print (msg)

    def genAndGetCode(self, opListAndType):
        self.output = '/* Begin Header autogenerated part */\n'
        filesToInclude = ()
        if (self.abi == "CXRAM"):
            filesToInclude += ("h2-tile-cxram.h",)
        filesToInclude += ("h2-common.h", "h2-%s-%s.h"%(str(self.archname),str(self.abi)))
        # print(filesToInclude)
        includeDir = os.path.dirname(os.path.realpath(sys.argv[0]))+"/HybroGen/include/"
        for f in filesToInclude:
            # print(includeDir+f)
            inputFile = open(includeDir+f, "r")
            data = inputFile.read()
            self.output += data
            inputFile.close()
        self.output += self.genHeader()
        self.lInsns = self.isa.getInsnListSem("RET", "i")
        self.lSem = ["RET"]
        for (semName, typeName) in opListAndType:
            self.lInsns.extend(self.isa.getInsnListSem(semName, typeName))
            self.lSem.append(semName)
            self.Trace("genAndGetCode for %s %s"%(semName, typeName))

        self.lSem = list(set(self.lSem))
        self.output += self.genMacroOrFunctionList()
        self.output += self.genGenerator()
        self.output += '\n/* End Header autogenerated part */\n'
        return self.output


    def buildMask(self, begin, end):
        return hex((1 << (begin - end + 1 )) - 1)

    def binToHexString(self, value):
        v = 0
        for c in value:
            v = v * 2
            if c == '1':
                v += 1
        return hex(v)

    def genHeader(self):
        elemSize = self.insnLenList[0]
        mask = hex(2**elemSize - 1)
        return "/* In memory instruction generator */\n#define {arch}_G{isize}(INSN){{ *(h2_asm_pc++) = (INSN);}}\n\n".format(arch = self.archname, isize = elemSize)


    def macroImplem (self, i, elemSize, maskElem):
        implem = []
        nbBit = 0
        s = ""
        for e in i["encoding"]:
            if e["onlybin"]:
                value = self.binToHexString(e["name"])
            else:
                value = e["name"]
            valueSize =  e["begin"] - e["end"] + 1

            if valueSize < (elemSize - nbBit):
                if implem == []:
                    s += "\t%s_G%s("%(self.archname, elemSize)
                if e["end"] != 0:
                    implem.append("(((%s >> %s) & %s) << %s)"%(value, e["end"], self.buildMask (e["begin"], e["end"]), str(elemSize - nbBit - valueSize)))
                else:
                    implem.append("((%s & %s) << %s)"%(value, self.buildMask (e["begin"], e["end"]), str(elemSize - nbBit - valueSize)))

                nbBit += valueSize
                if nbBit == elemSize:
                    s += "|".join(implem)
                    s += "); \\\n"
                    implem = []
                    nbBit = 0
            else:
                if nbBit != 0:
                    if e["end"] != 0:
                        implem.append("(((%s >> %s) & %s) >> %s)"%(value, e["end"], self.buildMask (e["begin"], e["end"]), str(valueSize - (elemSize - nbBit))))
                    else:
                        implem.append("((%s & %s) >> %s)"%(value, self.buildMask (e["begin"], e["end"]), str(valueSize - (elemSize - nbBit))))

                    s += "|".join(implem)
                    s += ");"
                    implem = []
                    valueSize -= (elemSize - nbBit)
                    nbBit = 0
                if valueSize > 0:
                    for j in range(int(valueSize/elemSize)):
                        s += "\t%s_G%s("%(self.archname, elemSize)
                        s += "((%s >> %s) & %s)); \\\n"%(value, str(valueSize- elemSize), maskElem)
                        valueSize -= elemSize
                    if valueSize > 0:
                        s += "\t%s_G%s("%(self.archname, elemSize)
                        implem.append("((%s & %s) << %s)"%(value, hex((1 << valueSize) - 1), str(elemSize - valueSize)))
                        nbBit += valueSize
                        valueSize = 0
        return s


    INSN_MACRO_DEFINITION = """#define {macro}({param}) do /* {sem} */ {{ {implem} }} while(0);\n"""
    INSN_FN_DEFINITION    = 'void {macro}({param}){{ /* {sem} */\n{implem}\n#ifdef H2_DEBUG\nprintf("%p : {macro}\\n", h2_asm_pc);\n#endif\n}}\n'

    def genMacroOrFunction (self, i):
        """ Generate C code for one instruction macro or function form """
        s = ""
        elemSize = self.insnLenList[0]
        maskElem = hex((1 << elemSize) - 1)
        binLen = 0
        paramList = []
        for p in i["encoding"]:
            binLen += p["begin"] - p["end"] + 1
        for p in json.loads(i["operand"]):
            paramList.append(p)
        implem = self.macroImplem(i, elemSize, maskElem)
        if self.debug :
            pList = ["int "+i for i in paramList]
            s += self.INSN_FN_DEFINITION.format(macro = i["macroname"], param = ",".join(pList) , sem = i["semname"], implem = implem)
        else :
            s += self.INSN_MACRO_DEFINITION.format(macro= i["macroname"], param = ",".join(paramList) , sem = i["semname"], implem = implem)
        return s

    def genMacroOrFunctionList(self):
        """ Generate C code for all needed single instruction  """
        s = "/* Single instruction binary code generator*/\n"
        for i in self.lInsns:
            s += self.genMacroOrFunction(i)
        return s



    SEM_FN_BODYW    = 'void {arch}_gen{sem}_{paramN}({paramList})\n{{\n{codeList}\n\t{warningMsg}\n}}'
    SEM_FAILED_MSG  = 'printf ("Warning, {sem} instruction generation failed\\n");\n\th2_codeGenerationOK = false;\n'
    SEM_MESG        = '\tprintf ("ValOrReg / arith / vLen / wLen / regNro / valueImm\\n");\n'
    SEM_PARAM       = '\tprintf ("P%d: %s/%c/%d/%d/%d\\n", {N}, (0==P{N}.ValOrReg)?"REG":"VAL", P{N}.arith, P{N}.wLen, P{N}.vLen, P{N}.valueImm);\n'
    SEM_INSN_FORMAT = """
    if (({P}.arith == '{ar}') && ({P}.wLen <= {wl}) && ({P}.vLen == {vl}) && {cond})
    {{
	{mn}({arg});
	return;
    }}"""
    OPTIM_MUL_POWER = """
    if ((P2.ValOrReg == VALUE) && (P2.arith == 'i') && (1 == P2.valueImm))
    { // X * 1 = X
        #ifdef H2_DEBUG
        printf ("Optim for * 1 (power)\\n");
        #endif
        if (P0.regNro != P1.regNro)              /* P1_MV_RR_I_32_1(int r0,int r1) mv */
           power_G32(((0xe & 0x3f) << 26)|((P0.regNro & 0x1f) << 21)|((P1.regNro & 0x1f) << 16)|((0x0 & 0xffff) >> 0));
         /* else no operation */

      return;
    }
    if ((P2.ValOrReg == VALUE) && (P2.arith == 'i') && (0 == P2.valueImm))
    { // X * 0 = 0
        #ifdef H2_DEBUG
        printf ("Optim for * 0 (power)\\n");
        #endif
	// P1_LI_RI_I_32_1(P0.regNro, P1.valueImm);
        power_G32(((0xe & 0x3f) << 26)|((P0.regNro & 0x1f) << 21)|((0x0 & 0x1f) << 16)|((P1.valueImm & 0xffff) >> 0));

      return;
    }
    if ((P2.ValOrReg == VALUE) && (P2.arith == 'i') && ((P2.valueImm != 0) && !(P2.valueImm & (P2.valueImm - 1))))
    { // X * NPowerOf2 = X << N (immediate shift left)
        #ifdef H2_DEBUG
        printf ("Optim for * power of 2 (power)\\n");
        #endif
	power_G32(((21 & 0x3f) << 26)|((P1.regNro & 0x1f) << 21)|((P0.regNro & 0x1f) << 16)
                |(((h2_log2(P2.valueImm)) & 0x1f) << 11)
                |((0  & 0x3F) <<6)|((31 & 0x3F) <<1)|(0x0 & 0x1));
      return;
    }"""
    OPTIM_MUL_AARCH64 = """
   if ((P2.ValOrReg == VALUE) && (P2.arith == 'i') && (0 == P2.valueImm))
    { // X * 0 = 0
        #ifdef H2_DEBUG
        printf ("Optim for *0 (aarch64)\\n");
        #endif
        aarch64_G32(((0x294 & 0x7ff) << 21)|((P2.valueImm & 0xffff) << 5)|((P0.regNro & 0x1f) >> 0));
        return;
    }
    if  ((P2.ValOrReg == VALUE) && (P2.arith == 'i') && ((P2.valueImm != 0) && !(P2.valueImm & (P2.valueImm - 1))))
    { // X * NPowerOf2 = X << N (immediate shift left)
        #ifdef H2_DEBUG
        printf ("Optim for * power of 2 (aarch64)\\n");
        #endif
        aarch64_G32(((0x34d & 0x3ff) << 22)|(((h2_log2(P2.valueImm) & 0x3f) << 16)|((0x0 & 0x3f) << 10)|((P1.regNro & 0x1f) << 5)|((P0.regNro & 0x1f) >> 0)));
    }"""
    OPTIM_R_AARCH64 = """
    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        aarch64_G32(((0x135032 & 0x3fffff) << 10)|((P1.regNro & 0x1f) << 5)|((P0.regNro & 0x1f) >> 0));
        #ifdef H2_DEBUG
        printf("%p : A64_LD1R_RR_I_32_4\\n", h2_asm_pc);
        #endif
        return;
    }
    """

    def genMulOptimization(self, archName):
        if archName == "power":
            return self.OPTIM_MUL_POWER
        elif archName == "aarch64":
            return self.OPTIM_MUL_AARCH64
        return ""

    def genROptimization(self, archname):
        return self.OPTIM_R_AARCH64

    def genOneInstructionSelector(self, semname):
        """ Generate one C instruction selector
        instruction selection are based on arithmetic (I/F/...), wordLen, vectorLen & immediate value
        SEM_INSN_FORMAT pattern is the basic selector.
        """
        is_mem_access  = semname in ['W']
        pReg = "P0" if not is_mem_access else "P1"
        # Get existing parameter variant number (rrr, rri, ...)
        paramList = list(set([len(i[0]) for i in self.isa.getInsnParameters(semname)]))
        if "MUL" == semname and self.archname in ("power", "aarch64"):
            codeList = [self.genMulOptimization (self.archname)]
        elif "R" == semname and self.archname == "aarch64":
            codeList = [self.genROptimization (self.archname)]
        else:
            codeList = []
        insnNumber = 0
        paramN = 0
        pList = ""
        for param in paramList:
            paramN = param
            #  print (paramN, semname)
            self.Trace("genGenerator : %s %s %s"%(self.archname, semname, param))
            params = []
            pList = ','.join (["h2_sValue_t P%d"%i for i in range (param)])
            for insn in self.lInsns:
                if insn["semname"].upper() == semname.upper():
                    if int(param) == 0: #Instruction without parameter
                        codeList.append ("{mn}();".format(mn = insn["macroname"]))
                    elif param == len(insn["parameters"]) and param > 0:
                        args = []
                        conds = []
                        nbr = 0
                        nbi = 0
                        for j, p in enumerate(insn["parameters"]):
                            if p == 'r':
                                args.append("P%d.regNro"%j)
                                conds.append("P%d.ValOrReg == REGISTER"%j)
                                nbr += 1
                            elif p == 'i':
                                args.append("P%d.valueImm"%j)
                                conds.append("P%d.ValOrReg == VALUE"%j)
                                nbi += 1
                        s = self.SEM_INSN_FORMAT.format (P = pReg, ar = insn["arith"], sn = insn["semname"], wl = insn["wordlen"], vl = insn["vectorlen"], cond = " && ".join(conds), mn = insn["macroname"], arg = ", ".join(args))
                        codeList.append (s)
                        insnNumber += 1
        # If generator has no parameter : no possible fail (no instruction to select)
        if 0 == len(paramList) or paramList[0] == 0 :
            w = ""
        else: # Generate C code when the instruction selector failed
            w = self.SEM_FAILED_MSG.format (sem = semname) # Warning msg
            w += self.SEM_MESG                             #
            for i in range(paramList[0]):
                w += self.SEM_PARAM.format (N=i)           # add "printf" for each input h2_sValue parameter
        return self.SEM_FN_BODYW.format(arch=self.archname, sem=semname, paramN=paramN, paramList = pList, codeList = "\n".join (codeList), warningMsg = w)

    def genGenerator(self):
        """ Generate instruction selector & low level optimisations"""
        s = ""
        for semname in self.lSem:
            s += self.genOneInstructionSelector (semname)+"\n"
        return s

    def getRegisterIOT(self, arith="i"):
        return (self.db.getRegisterList(self.archname, self.abi, "I", arith), self.db.getRegisterList(self.archname,self.abi, "O", arith), self.db.getRegisterList(self.archname, self.abi,"T", arith))

if __name__ == '__main__':
    print("/* Warning: class */")
