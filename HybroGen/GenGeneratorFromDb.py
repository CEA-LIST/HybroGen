#!/usr/bin/env python3

import sys, os
from HybroGen.IsaDb  import IsaDb
from HybroGen.Insn import Insn
from HybroGen.ProxyDb import *

class GenGeneratorFromDb:

    def __init__(self, archName, extList, abi, dbConf, args):
        self.db = ProxyDb(dbConf["host"], dbConf["dbname"], dbConf["user"], dbConf["pwd"])
        self.isa = IsaDb(self.db, archName, extList)
        self.insnLenList = self.isa.getWordSizeFromDb()
        self.insnLenList.sort()
        self.archname = archName
        self.debug = args.debug
        self.verbose = args.verboseBackend
        self.extList = extList
        self.abi = abi

    def Trace(self, msg):
        if self.verbose:
            print (msg)

    def genAndGetCode(self, opListAndType):
        self.output = '/* Begin Header autogenerated part */\n'
        filesToInclude = ()
        if (self.abi == "CXRAM"):
            filesToInclude += ("h2-tile-cxram.h",)
        filesToInclude += ("h2-common.h", "h2-%s-%s.h"%(str(self.archname),str(self.abi)))
        # print(filesToInclude)
        includeDir = os.path.dirname(os.path.realpath(sys.argv[0]))+"/HybroGen/include/"
        for f in filesToInclude:
            # print(includeDir+f)
            inputFile = open(includeDir+f, "r")
            data = inputFile.read()
            self.output += data
            inputFile.close()
        self.output += self.genHeader()
        # Add mandatory instructions in instruction list
        possiblyInsnToBeAdded = [("RET", "i"),  # Return
               ("W",   "i"), # W for low level optimization : Store 0 in memory
                             # & store on stack
               ("SL",  "i"), # SL for low level optimization : Replace MUL by SL
               ("ADD", "i"), # ADD for array address computations
               ("SUB", "i"), # SUB for stack register calle save
               ("MV",  "i"), # MV for const propagation even with FP arith.
                         ]
        insnToBeAdded = []
        for i in possiblyInsnToBeAdded:
            if not i in opListAndType:
                insnToBeAdded += (i,)
        self.lSem = []
        self.lInsns = []
        for semname, arith in insnToBeAdded:
            self.lInsns.extend(self.isa.getInsnListSem(semname, arith))
            self.lSem += [semname]
        for semName, arith in opListAndType:
            # print (semName, arith)
            insnDef = self.isa.getInsnListSem(semName, arith)
            self.lInsns.extend(insnDef)
            self.lSem.append(semName)
            # else:
            #     print ("already inserted", semName)
        self.lSem = list(set(self.lSem))
        self.output += self.genMacroOrFunctionList()
        self.output += self.genGenerator()
        self.output += '\n/* End Header autogenerated part */\n'
        return self.output


    def buildMask(self, begin, end):
        return hex((1 << (begin - end + 1 )) - 1)

    def binToHexString(self, value):
        v = 0
        for c in value:
            v = v * 2
            if c == '1':
                v += 1
        return hex(v)

    def genHeader(self):
        elemSize = self.insnLenList[0]
        mask = hex(2**elemSize - 1)
        return "/* In memory instruction generator */\n#define {arch}_G{isize}(INSN){{ *(h2_asm_pc++) = (INSN);}}\n\n".format(arch = self.archname, isize = elemSize)


    def macroImplem (self, i, elemSize, maskElem):
        implem = []
        nbBit = 0
        s = ""
        for e in i["encoding"]:
            if e["onlybin"]:
                value = self.binToHexString(e["name"])
            else:
                value = e["name"]
            valueSize =  e["begin"] - e["end"] + 1

            if valueSize < (elemSize - nbBit):
                if implem == []:
                    s += "\t%s_G%s("%(self.archname, elemSize)
                if e["end"] != 0:
                    implem.append("(((%s >> %s) & %s) << %s)"%(value, e["end"], self.buildMask (e["begin"], e["end"]), str(elemSize - nbBit - valueSize)))
                else:
                    implem.append("((%s & %s) << %s)"%(value, self.buildMask (e["begin"], e["end"]), str(elemSize - nbBit - valueSize)))

                nbBit += valueSize
                if nbBit == elemSize:
                    s += "|".join(implem)
                    s += "); \\\n"
                    implem = []
                    nbBit = 0
            else:
                if nbBit != 0:
                    if e["end"] != 0:
                        implem.append("(((%s >> %s) & %s) >> %s)"%(value, e["end"], self.buildMask (e["begin"], e["end"]), str(valueSize - (elemSize - nbBit))))
                    else:
                        implem.append("((%s & %s) >> %s)"%(value, self.buildMask (e["begin"], e["end"]), str(valueSize - (elemSize - nbBit))))

                    s += "|".join(implem)
                    s += ");"
                    implem = []
                    valueSize -= (elemSize - nbBit)
                    nbBit = 0
                if valueSize > 0:
                    for j in range(int(valueSize/elemSize)):
                        s += "\t%s_G%s("%(self.archname, elemSize)
                        s += "((%s >> %s) & %s)); \\\n"%(value, str(valueSize- elemSize), maskElem)
                        valueSize -= elemSize
                    if valueSize > 0:
                        s += "\t%s_G%s("%(self.archname, elemSize)
                        implem.append("((%s & %s) << %s)"%(value, hex((1 << valueSize) - 1), str(elemSize - valueSize)))
                        nbBit += valueSize
                        valueSize = 0
        return s


    INSN_MACRO_DEFINITION = """#define {macro}({param}) do /* {sem} */ {{ {implem} }} while(0);\n"""
    INSN_FN_DEFINITION    = 'void {macro}({param}){{ /* {sem} */\n{implem}\n#ifdef H2_DEBUG_INSN\nprintf("%p : {macro}\\n", h2_asm_pc);\n#endif\n}}\n'

    def genMacroOrFunction (self, i):
        """ Generate C code for one instruction macro or function form """
        s = ""
        elemSize = self.insnLenList[0]
        maskElem = hex((1 << elemSize) - 1)
        binLen = 0
        paramList = []
        for p in i["encoding"]:
            binLen += p["begin"] - p["end"] + 1
        for p in json.loads(i["operand"]):
            paramList.append(p)
        implem = self.macroImplem(i, elemSize, maskElem)
        if self.debug : # For run-time debug, generate C function
            pList = ["int "+i for i in paramList]
            s += self.INSN_FN_DEFINITION.format(macro = i["macroname"], param = ",".join(pList) , sem = i["semname"], implem = implem)
        else :          # else generate C macro
            s += self.INSN_MACRO_DEFINITION.format(macro= i["macroname"], param = ",".join(paramList) , sem = i["semname"], implem = implem)
        return s

    def genMacroOrFunctionList(self):
        """ Generate C code for all needed single instruction  """
        s = "/* Single instruction binary code generator*/\n"
        for i in self.lInsns:
            s += self.genMacroOrFunction(i)
        return s



    SEM_FN_BODYW    = 'h2_sValue_t {arch}_gen{sem}_{paramN}({paramList})\n{{\n{codeList}\n\t{warningMsg}\n}}'
    SEM_FN_HEADER   = 'h2_sValue_t {arch}_gen{sem}_{paramN}({paramList});\n'
    SEM_FAILED_MSG  = 'printf ("Warning, {sem} instruction generation failed\\n");\n\th2_codeGenerationOK = false;\n'
    SEM_HEAD_MSG    = 'printf ("Start code gen for {sem} instruction\\n");\n'
    SEM_MESG        = '\tprintf ("ValOrReg / arith / wLen / vLen / regNro / valueImm\\n");\n'
    SEM_PARAM       = '\tprintf ("P%d: %s/%c/%d/%d/%d\\n", {N}, (0==P{N}.ValOrReg)?"REG":"VAL", P{N}.arith, P{N}.wLen, P{N}.vLen, P{N}.valueImm);\n'
    SEM_INSN_FORMAT = """
    if (({P}.arith == '{ar}') && ({P}.wLen <= {wl}) && ({P}.vLen == {vl}) && {cond})
    {{
	{mn}({arg});
	return {P};
    }}"""
    def addOptimisationCodeFile (self, semname, archName):
        codeList  = []
        Root = os.path.dirname(os.path.realpath(sys.argv[0]))+"/HybroGen/OptimCodeGen/"
        try:
            fileName = Root+"OPTIM_%s_GENERIC.codegen"%semname
            # print(fileName)
            with open (fileName, "r") as f:
                codeList += [f.read()]
        except:
            codeList += ["// No generic optimisation for %s\n"%(semname)]
        try:
            fileName = Root+"OPTIM_%s_%s.codegen"%(semname, archName)
            # print(fileName)
            with open (fileName, "r") as f:
                codeList += [f.read()]
        except:
            codeList += ["// No specific optimisation for %s/%s\n"%(semname, archName)]
        return codeList

    def genOneInstructionSelector(self, semname):
        """ Generate one C instruction selector
        instruction selection are based on arithmetic (I/F/...), wordLen, vectorLen & immediate value
        SEM_INSN_FORMAT pattern is the basic selector.
        """
        # Get existing parameter variant number (rrr, rri, ...)
        paramList = list(set([len(i[0]) for i in self.isa.getInsnParameters(semname)]))
        # Generate header message before code generation
        if 0 == len(paramList) or paramList[0] == 0 :

            codeList = []
        else: #
            codeList = ["#ifdef H2_DEBUG_INSN"]  # Warning msg
            codeList += [self.SEM_HEAD_MSG.format (sem = semname)]  # Warning msg
            codeList += [self.SEM_MESG]                            #
            for i in range(paramList[0]):
                codeList += [self.SEM_PARAM.format (N=i)]          # add "printf" for each input h2_sValue parameter
            codeList += ["#endif // H2_DEBUG_INSN"]

        is_mem_access  = semname in ['W']
        pReg = "P0" if not is_mem_access else "P1"
        # Include optimisation specific for operator or operator / architecture
        codeList +=  self.addOptimisationCodeFile(semname, self.archname)
        # If generator has no parameter : no possible fail (no instruction to select)
        # print (semname, paramList)
        if len(paramList) > 0 and paramList[0] >= 1 : # Add dynamic reg alloc for 1 param
            codeList.append("""\tif ((P0.ValOrReg == H2REGISTER) && (P0.regNro == -1))\n\t\tP0.regNro = h2_getReg();""")
        if len(paramList) > 0 and paramList[0] >= 2 : # Add dynamic reg alloc for 2 param
             codeList.append("""\tif ((P1.ValOrReg == H2REGISTER) && (P1.regNro == -1))\n\t\tP1.regNro = h2_getReg();""")
        insnNumber = 0
        paramN = 0
        pList = ""
        for param in paramList:
            paramN = param
            # print (paramN, semname)
            self.Trace("genGenerator : %s %s %s"%(self.archname, semname, param))
            params = []
            pList = ','.join (["h2_sValue_t P%d"%i for i in range (param)])
            for insn in self.lInsns:
                if insn["semname"].upper() == semname.upper():
                    if int(param) == 0: #Instruction without parameter
                        codeList.append ("{mn}();".format(mn = insn["macroname"]))
                    elif param == len(insn["parameters"]) and param > 0:
                        args = []
                        conds = []
                        nbr = 0
                        nbi = 0
                        for j, p in enumerate(insn["parameters"]):
                            if p == 'r':
                                args.append("P%d.regNro"%j)
                                conds.append("P%d.ValOrReg == H2REGISTER"%j)
                                nbr += 1
                            elif p == 'i':
                                args.append("P%d.valueImm"%j)
                                conds.append("P%d.ValOrReg == H2VALUE"%j)
                                nbi += 1
                        s = self.SEM_INSN_FORMAT.format (P = pReg, ar = insn["arith"], sn = insn["semname"], wl = insn["wordlen"], vl = insn["vectorlen"], cond = " && ".join(conds), mn = insn["macroname"], arg = ", ".join(args))
                        codeList.append (s)
                        insnNumber += 1
        # If generator has no parameter : no possible fail (no instruction to select)
        if 0 == len(paramList) or paramList[0] == 0 :
            w = ""
        else: # Generate C code when the instruction selector failed
            w = self.SEM_FAILED_MSG.format (sem = semname) # Warning msg
            w += self.SEM_MESG                             #
            for i in range(paramList[0]):
                w += self.SEM_PARAM.format (N=i)           # add "printf" for each input h2_sValue parameter
            w += "return immValueZero;";
        return self.SEM_FN_BODYW.format(arch=self.archname, sem=semname, paramN=paramN, paramList = pList, codeList = "\n".join (codeList), warningMsg = w)

    def genOneInstructionSelectorHeader(self, semname):
        """ Generate one C instruction selector header
        """
        is_mem_access  = semname in ['W']
        pReg = "P0" if not is_mem_access else "P1"
        # Get existing parameter variant number (rrr, rri, ...)
        paramList = list(set([len(i[0]) for i in self.isa.getInsnParameters(semname)]))
        insnNumber = 0
        paramN = 0
        pList = ""
        for param in paramList:
            paramN = param
            #  print (paramN, semname)
            self.Trace("genGenerator : %s %s %s"%(self.archname, semname, param))
            params = []
            pList = ','.join (["h2_sValue_t P%d"%i for i in range (param)])
        # If generator has no parameter : no possible fail (no instruction to select)
        if 0 == len(paramList) or paramList[0] == 0 :
            w = ""
        else: # Generate C code when the instruction selector failed
            w = self.SEM_FAILED_MSG.format (sem = semname) # Warning msg
            w += self.SEM_MESG                             #
            for i in range(paramList[0]):
                w += self.SEM_PARAM.format (N=i)           # add "printf" for each input h2_sValue parameter
            w += "return immValueZero;";
        return self.SEM_FN_HEADER.format(arch=self.archname, sem=semname, paramN=paramN, paramList = pList)

    def genGenerator(self):
        """ Generate instruction selector & low level optimisations"""
        s = ""
        for semname in self.lSem:
            s += self.genOneInstructionSelectorHeader (semname)
        for semname in self.lSem:
            s += self.genOneInstructionSelector (semname)+"\n"
        return s

    def getRegisterIOT(self, arith="i"):
        return (self.db.getRegisterList(self.archname, self.abi, "I", arith), self.db.getRegisterList(self.archname,self.abi, "O", arith), self.db.getRegisterList(self.archname, self.abi,"T", arith))

if __name__ == '__main__':
    print("/* Warning: class */")
