#!/usr/bin/env python3

import sys, os
from HybroGen.IsaDb  import IsaDb
from HybroGen.Insn import Insn
from HybroGen.ProxyDb import *

class GenGeneratorFromDb:

    def __init__(self, archName, extList, abi, dbConf, verbose = False, debug = False):
        self.db = ProxyDb(dbConf["host"], dbConf["dbname"], dbConf["user"], dbConf["pwd"])
        self.isa = IsaDb(self.db, archName, extList)
        self.insnLenList = self.isa.getWordSizeFromDb()
        self.insnLenList.sort()
        self.archname = archName
        self.debug = debug
        self.verbose = verbose
        self.extList = extList
        self.abi = abi

    def genAndGetCode(self, opListAndType):
        self.output = '/* Begin Header autogenerated part */\n'
        filesToInclude = ()
        if (self.abi == "CXRAM"):
            filesToInclude += ("h2-tile-cxram.h",)
        filesToInclude += ("h2-common.h", "h2-%s-%s.h"%(str(self.archname),str(self.abi)))
        # print(filesToInclude)
        includeDir = os.path.dirname(os.path.realpath(sys.argv[0]))+"/HybroGen/include/"
        for f in filesToInclude:
            # print(includeDir+f)
            inputFile = open(includeDir+f, "r")
            data = inputFile.read()
            self.output += data
            inputFile.close()
        self.output += self.genHeader()
        self.lInsns = self.isa.getInsnListSem("RET", "i")
        self.lSem = ["RET"]
        for (semName, typeName) in opListAndType:
            self.lInsns.extend(self.isa.getInsnListSem(semName, typeName))
            self.lSem.append(semName)
            if (self.verbose):
                print("genAndGetCode for %s %s"%(semName, typeName))

        self.lSem = list(set(self.lSem))
        self.output += self.genMacroOrFunction()
        self.output += self.genGenerator()
        self.output += '\n/* End Header autogenerated part */\n'
        return self.output


    def buildMask(self, begin, end):
        return hex((1 << (begin - end + 1 )) - 1)

    def binToHexString(self, value):
        v = 0
        for c in value:
            v = v * 2
            if c == '1':
                v += 1
        return hex(v)

    def genHeader(self):
        elemSize = self.insnLenList[0]
        mask = hex(2**elemSize - 1)
        t = """
#define {arch}_G{isize}(INSN){{ *(h2_asm_pc++) = (INSN);}}
""".format(arch = self.archname, isize = elemSize)
        return t

    def genMacroOrFunction(self):
        elemSize = self.insnLenList[0]
        maskElem = hex((1 << elemSize) - 1)
        s = ""
        for i in self.lInsns:
            binLen = 0
            paramList = []
            for p in i["encoding"]:
                binLen += p["begin"] - p["end"] + 1
            for p in json.loads(i["operand"]):
                paramList.append(p)
            if not self.debug :
                s += """
#define {macro}({param}) /* {sem} */ \\
do {{ \\
""".format(macro= i["macroname"], param = ",".join(paramList) , sem = i["semname"])
            else :
                if len(paramList) == 0:
                    s += """
void {macro}(void){{ /* {sem} */
#ifdef H2_DEBUG
    printf("%p : {macro}\\n", h2_asm_pc);
#endif
""".format(macro= i["macroname"] , sem = i["semname"])
                else :
                    s += """
void {macro}(int {param}){{ /* {sem} */
#ifdef H2_DEBUG
    printf("%p : {macro}\\n", h2_asm_pc);
#endif
""".format(macro= i["macroname"], param = ", int ".join(paramList) , sem = i["semname"])

            tmp = []
            nbBit = 0
            for e in i["encoding"]:
                if e["onlybin"]:
                    value = self.binToHexString(e["name"])
                else:
                    value = e["name"]
                valueSize =  e["begin"] - e["end"] + 1

                if valueSize < (elemSize - nbBit):
                    if tmp == []:
                        s += "\t%s_G%s("%(self.archname, elemSize)
                    if e["end"] != 0:
                        tmp.append("(((%s >> %s) & %s) << %s)"%(value, e["end"], self.buildMask (e["begin"], e["end"]), str(elemSize - nbBit - valueSize)))
                    else:
                        tmp.append("((%s & %s) << %s)"%(value, self.buildMask (e["begin"], e["end"]), str(elemSize - nbBit - valueSize)))

                    nbBit += valueSize
                    if nbBit == elemSize:
                        s += "|".join(tmp)
                        s += "); \\\n"
                        tmp = []
                        nbBit = 0

                else:
                    if nbBit != 0:
                        if e["end"] != 0:
                            tmp.append("(((%s >> %s) & %s) >> %s)"%(value, e["end"], self.buildMask (e["begin"], e["end"]), str(valueSize - (elemSize - nbBit))))
                        else:
                            tmp.append("((%s & %s) >> %s)"%(value, self.buildMask (e["begin"], e["end"]), str(valueSize - (elemSize - nbBit))))

                        s += "|".join(tmp)
                        s += "); \\\n"
                        tmp = []
                        valueSize -= (elemSize - nbBit)
                        nbBit = 0
                    if valueSize > 0:
                        for j in range(int(valueSize/elemSize)):
                            s += "\t%s_G%s("%(self.archname, elemSize)
                            s += "((%s >> %s) & %s)); \\\n"%(value, str(valueSize- elemSize), maskElem)
                            valueSize -= elemSize
                        if valueSize > 0:
                            s += "\t%s_G%s("%(self.archname, elemSize)
                            tmp.append("((%s & %s) << %s)"%(value, hex((1 << valueSize) - 1), str(elemSize - valueSize)))
                            nbBit += valueSize
                            valueSize = 0
            if not self.debug:
                s += "} while(0) \n"
            else:
                s += "}  \n"
        return s

    def genGenerator(self):
        s = ""
        for semname in self.lSem:
            #is_mem_access  = semname in ['R', 'W']
            is_mem_access  = semname in ['W']
            pReg = "P0" if not is_mem_access else "P1"
            paramlist = list(set([len(i[0]) for i in self.isa.getInsnParameters(semname)]))
            #print(semname, paramlist)
            for param in paramlist:
                if self.verbose :
                    print("genGenerator : %s %s %s"%(self.archname, semname, param))
                params = []
                for i in range(param):
                    params.append("h2_sValue_t P%d"%i)
                s += "void %s_gen%s_%s(%s)\n{\n"%(self.archname, semname, param, ", ".join(params))
                nb_if = 0
                for insn in self.lInsns:
                    if insn["semname"].upper() == semname.upper():
                        #Instruction without parameter
                        if int(param) == 0:
                            s += """
    {mn}();
""".format(mn = insn["macroname"])
                            break
                        elif param == len(insn["parameters"]) and param > 0:
                            args = []
                            conds = []
                            nbr = 0
                            nbi = 0
                            for j, p in enumerate(insn["parameters"]):
                                if p == 'r':
                                    args.append("P%d.regNro"%j)
                                    conds.append("P%d.ValOrReg == REGISTER"%j)
                                    nbr += 1
                                elif p == 'i':
                                    args.append("P%d.valueImm"%j)
                                    conds.append("P%d.ValOrReg == VALUE"%j)
                                    nbi += 1
                            if nb_if == 0:
                                nb_if += 1
                                s += """
    if (({P}.arith == '{ar}') && ({P}.wLen <= {wl}) && ({P}.vLen == {vl}) && {cond})
    {{
        {mn}({arg});
    }}
    """.format (P = pReg, ar = insn["arith"], sn = insn["semname"], wl = insn["wordlen"], vl = insn["vectorlen"], cond = " && ".join(conds), mn = insn["macroname"], arg = ", ".join(args))

                            else:
                                nb_if += 1
                                s += """
    else if (({P}.arith == '{ar}') && ({P}.wLen <= {wl}) && ({P}.vLen == {vl}) && {cond})
    {{
        {mn}({arg});
    }}
    """.format (P = pReg, ar = insn["arith"], sn = insn["semname"], wl = insn["wordlen"], vl = insn["vectorlen"], cond = " && ".join(conds), mn = insn["macroname"], arg = ", ".join(args))
                if param == 0:
                    s += """
}
"""
                elif nb_if == 0:
                    s += """
    printf("Warning, generation of {sn} is not possible with this arguments P0: %c, %i, %i, {ty} \\n", P0.arith, P0.wLen, P0.vLen, {ValOrReg});
    h2_codeGenerationOK = false;

}}
""".format (sn=semname,  ty=" ,".join([" P"+str(p)+": %i" for p in range(param)]), ValOrReg=" ,".join(["P"+str(p)+".ValOrReg" for p in range(param)]))

                else:
                    s += """
    else
    {{
        printf("Warning, generation of {sn} is not possible with this arguments P0: %c, %i, %i, {ty} \\n", P0.arith, P0.wLen, P0.vLen, {ValOrReg});
        h2_codeGenerationOK = false;
    }}
}}
""".format (sn=semname,  ty=" ,".join([" P"+str(p)+": %i" for p in range(param)]), ValOrReg=" ,".join(["P"+str(p)+".ValOrReg" for p in range(param)]))
        return s

    def getRegisterIOT(self, arith="i"):
        return (self.db.getRegisterList(self.archname, self.abi, "I", arith), self.db.getRegisterList(self.archname,self.abi, "O", arith), self.db.getRegisterList(self.archname, self.abi,"T", arith))

if __name__ == '__main__':
    print("/* Warning: class */")
