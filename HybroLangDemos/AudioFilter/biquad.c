/* Begin Header autogenerated part */
#include "h2-riscv-RV32G.h"
#define riscv_G32(INSN){ *(h2_asm_pc++) = (INSN);}

#define RV32I_RET__I_32() /* RET */ \
do { \
	riscv_G32(((0x8067 >> 0) & 0xffffffff)); \
} while(0) 

#define RV32I_SUB_RRR_I_32(r3,r1,r2) /* SUB */ \
do { \
	riscv_G32(((0x20 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
} while(0) 

#define RV32F_FSUB_S_RRR_F_32(r3,r1,r2) /* SUB */ \
do { \
	riscv_G32(((0x4 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x53 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_SB_RRI_I_8(r1,r2,i1) /* W */ \
do { \
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_SH_RRI_I_16(r1,r2,i1) /* W */ \
do { \
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_SW_RRI_I_32(r1,r2,i1) /* W */ \
do { \
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x2 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_JAL_RI_I_32(r3,i1) /* BA */ \
do { \
	riscv_G32((((i1 >> 20) & 0x1) << 31)|(((i1 >> 1) & 0x3ff) << 21)|(((i1 >> 11) & 0x1) << 20)|(((i1 >> 12) & 0xff) << 12)|((r3 & 0x1f) << 7)|((0x6f & 0x7f) >> 0)); \
} while(0) 

#define RV32I_ADDI_RRI_I_32(r1,r0,i0) /* ADD */ \
do { \
	riscv_G32(((i0 & 0xfff) << 20)|((r0 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r1 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_ADD_RRR_I_32(r3,r1,r2) /* ADD */ \
do { \
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
} while(0) 

#define RV32F_FADD_S_RRR_F_32(r3,r1,r2) /* ADD */ \
do { \
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x53 & 0x7f) >> 0)); \
} while(0) 

#define RV32D_FADD_D_RRR_F_64(r3,r1,r2) /* ADD */ \
do { \
	riscv_G32(((0x1 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x53 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_BGE_RRI_I_32(r1,r2,i1) /* BGE */ \
do { \
	riscv_G32((((i1 >> 12) & 0x1) << 31)|(((i1 >> 5) & 0x3f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x5 & 0x7) << 12)|(((i1 >> 1) & 0xf) << 8)|(((i1 >> 11) & 0x1) << 7)|((0x63 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_LB_RRI_I_8(r3,r1,i1) /* R */ \
do { \
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x3 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_LH_RRI_I_16(r3,r1,i1) /* R */ \
do { \
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x3 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_LW_RRI_I_32(r3,r1,i1) /* R */ \
do { \
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x2 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x3 & 0x7f) >> 0)); \
} while(0) 

#define RV32M_MUL_RRR_I_32(r3,r1,r2) /* MUL */ \
do { \
	riscv_G32(((0x1 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
} while(0) 

#define RV32F_FMUL_S_RRR_F_32(r3,r1,r2) /* MUL */ \
do { \
	riscv_G32(((0x8 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x53 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_MV_RR_I_32(r0,r1) /* MV */ \
do { \
	riscv_G32(((0x0 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r0 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0) 

#define RV32I_MV_RI_I_32(r3,i1) /* MV */ \
do { \
	riscv_G32(((i1 & 0xfff) << 20)|((0x6 & 0xff) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0) 

#define RV32F_FMV_S_RR_F_32(r3,r1) /* MV */ \
do { \
	riscv_G32(((0x10 & 0x7f) << 25)|((r1 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x53 & 0x7f) >> 0)); \
} while(0) 

#define RV32D_FMV_D_RR_F_64(r3,r1) /* MV */ \
do { \
	riscv_G32(((0x11 & 0x7f) << 25)|((r1 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x53 & 0x7f) >> 0)); \
} while(0) 
void riscv_genMV_2(h2_sValue_t P0, h2_sValue_t P1)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        RV32I_MV_RR_I_32(P0.regNro, P1.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
        RV32I_MV_RI_I_32(P0.regNro, P1.valueImm);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        RV32F_FMV_S_RR_F_32(P0.regNro, P1.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        RV32D_FMV_D_RR_F_64(P0.regNro, P1.regNro);
    }
    
    else
    {
        printf("Warning, generation of MV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genADD_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_ADDI_RRI_I_32(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32I_ADD_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32F_FADD_S_RRR_F_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32D_FADD_D_RRR_F_64(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of ADD is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genMUL_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32M_MUL_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32F_FMUL_S_RRR_F_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of MUL is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genMUL_4(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2, h2_sValue_t P3)
{

    printf("Warning, generation of MUL is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i , P3: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg ,P3.ValOrReg);
    h2_codeGenerationOK = 0;

}
void riscv_genW_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P1.arith == 'i') && (P1.wLen <= 8) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_SB_RRI_I_8(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else if ((P1.arith == 'i') && (P1.wLen <= 16) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_SH_RRI_I_16(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_SW_RRI_I_32(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else
    {
        printf("Warning, generation of W is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genRET_0()
{

    RV32I_RET__I_32();

}
void riscv_genBA_2(h2_sValue_t P0, h2_sValue_t P1)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
        RV32I_JAL_RI_I_32(P0.regNro, P1.valueImm);
    }
    
    else
    {
        printf("Warning, generation of BA is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genBGE_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_BGE_RRI_I_32(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else
    {
        printf("Warning, generation of BGE is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genR_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P1.arith == 'i') && (P1.wLen <= 8) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_LB_RRI_I_8(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else if ((P1.arith == 'i') && (P1.wLen <= 16) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_LH_RRI_I_16(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_LW_RRI_I_32(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else
    {
        printf("Warning, generation of R is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genSUB_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32I_SUB_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32F_FSUB_S_RRR_F_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of SUB is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}

/* End Header autogenerated part */
// -*- c -*-

#include <stdio.h>

typedef  void (*piff)(float *, float *, int size);

// Extract from sox.sourceforge.net
// https://sourceforge.net/p/sox/code/ci/master/tree/src/biquad.c
// Wav Float file format : http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html
h2_insn_t * genFilter (h2_insn_t * ptr, float b0, float b1, float b2, float a1, float a2)
{
/* Code Generation of 14 instructions */
/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t signalIn = {REGISTER, 'f', 1, 32, 10, 0};
	h2_sValue_t signalOut = {REGISTER, 'f', 1, 32, 11, 0};
	h2_sValue_t len = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t o0 = {REGISTER, 'f', 1, 32, 0, 0};
	h2_sValue_t o1 = {REGISTER, 'f', 1, 32, 1, 0};
	h2_sValue_t o2 = {REGISTER, 'f', 1, 32, 30, 0};
	h2_sValue_t i1 = {REGISTER, 'f', 1, 32, 31, 0};
	h2_sValue_t i2 = {REGISTER, 'f', 1, 32, 2, 0};
	h2_sValue_t tmp = {REGISTER, 'f', 1, 32, 3, 0};
	h2_sValue_t i = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000000 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000001 = {REGISTER, 'f', 1, 32, 4, 0};
	h2_sValue_t h2_00000002 = {REGISTER, 'f', 1, 32, 4, 0};
	h2_sValue_t h2_00000003 = {REGISTER, 'f', 1, 32, 4, 0};
	h2_sValue_t h2_00000004 = {REGISTER, 'f', 1, 32, 4, 0};
	h2_sValue_t h2_00000005 = {REGISTER, 'f', 1, 32, 4, 0};
	h2_sValue_t h2_00000006 = {REGISTER, 'f', 1, 32, 4, 0};
	h2_sValue_t h2_00000007 = {REGISTER, 'f', 1, 32, 5, 0};
	h2_sValue_t h2_00000008 = {REGISTER, 'f', 1, 32, 5, 0};
	h2_sValue_t h2_00000009 = {REGISTER, 'f', 1, 32, 4, 0};
	h2_sValue_t h2_00000010 = {REGISTER, 'f', 1, 32, 5, 0};
	h2_sValue_t h2_00000011 = {REGISTER, 'f', 1, 32, 5, 0};
	h2_sValue_t h2_00000012 = {REGISTER, 'f', 1, 32, 4, 0};
	h2_sValue_t h2_00000013 = {REGISTER, 'f', 1, 32, 5, 0};
	h2_sValue_t h2_00000014 = {REGISTER, 'f', 1, 32, 5, 0};
	h2_sValue_t h2_00000015 = {REGISTER, 'f', 1, 32, 4, 0};
	h2_sValue_t h2_00000016 = {REGISTER, 'f', 1, 32, 5, 0};
	h2_sValue_t h2_00000017 = {REGISTER, 'f', 1, 32, 5, 0};
	h2_sValue_t h2_00000018 = {REGISTER, 'f', 1, 32, 4, 0};
	h2_sValue_t h2_00000019 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000020 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000021 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000022 = {REGISTER, 'i', 1, 32, 7, 0};
	h2_sValue_t h2_00000023 = {REGISTER, 'i', 1, 32, 7, 0};


/* Label  table :*/
#define riscv_genLABEL(LABEL_ID) labelAddresses[LABEL_ID] = h2_asm_pc;
h2_insn_t   * labelAddresses []={
	0, /* h2_begin_00000000 */
	#define h2_begin_00000000 0
	0, /* h2_end_00000001 */
	#define h2_end_00000001 1
	};


	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = 1;
	riscv_genMV_2(h2_00000000, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 0});
	riscv_genMV_2(i, h2_00000000);
	riscv_genLABEL(h2_begin_00000000);
	riscv_genBGE_3(i, len, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((labelAddresses [h2_end_00000001] - h2_asm_pc)*4)});
	riscv_genMV_2(h2_00000001, (h2_sValue_t) {VALUE, 'f', 1, 32, 0, (32 * 1) / 8});
	riscv_genMUL_3(h2_00000002, i, h2_00000001);
	riscv_genADD_3(h2_00000003, signalIn, h2_00000002);
	riscv_genR_3(h2_00000004, h2_00000003, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(0)});
	riscv_genMV_2(tmp, h2_00000004);
	riscv_genMV_2(h2_00000005, (h2_sValue_t) {VALUE, 'f', 1, 32, 0, (b0)});
	riscv_genMUL_3(h2_00000006, tmp, h2_00000005);
	riscv_genMV_2(h2_00000007, (h2_sValue_t) {VALUE, 'f', 1, 32, 0, (b1)});
	riscv_genMUL_3(h2_00000008, i1, h2_00000007);
	riscv_genADD_3(h2_00000009, h2_00000006, h2_00000008);
	riscv_genMV_2(h2_00000010, (h2_sValue_t) {VALUE, 'f', 1, 32, 0, (b2)});
	riscv_genMUL_3(h2_00000011, i2, h2_00000010);
	riscv_genADD_3(h2_00000012, h2_00000009, h2_00000011);
	riscv_genMV_2(h2_00000013, (h2_sValue_t) {VALUE, 'f', 1, 32, 0, (a1)});
	riscv_genMUL_3(h2_00000014, o1, h2_00000013);
	riscv_genSUB_3(h2_00000015, h2_00000012, h2_00000014);
	riscv_genMV_2(h2_00000016, (h2_sValue_t) {VALUE, 'f', 1, 32, 0, (a2)});
	riscv_genMUL_3(h2_00000017, o2, h2_00000016);
	riscv_genSUB_3(h2_00000018, h2_00000015, h2_00000017);
	riscv_genMV_2(o0, h2_00000018);
	riscv_genMV_2(i2, i1);
	riscv_genMV_2(i1, tmp);
	riscv_genMV_2(o2, o1);
	riscv_genMV_2(o1, o0);
	riscv_genMV_2(h2_00000019, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (32 * 1) / 8});
	riscv_genMUL_3(h2_00000020, i, h2_00000019);
	riscv_genADD_3(h2_00000021, signalOut, h2_00000020);
	riscv_genW_3(h2_00000021, o0, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(0)});
	riscv_genMV_2(h2_00000022, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 1});
	riscv_genADD_3(h2_00000023, i, h2_00000022);
	riscv_genMV_2(i, h2_00000023);
	riscv_genBA_2((h2_sValue_t) {REGISTER, 'i', 1, 32, 0, 0}, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((labelAddresses [h2_begin_00000000] - h2_asm_pc)*4)});
	riscv_genLABEL(h2_end_00000001);
	riscv_genRET_0();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = labelAddresses [h2_begin_00000000];
	riscv_genBGE_3(i, len, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)((labelAddresses [h2_end_00000001] - h2_asm_pc)*4)});
	h2_asm_pc = h2_save_asm_pc;
	iflush(ptr, h2_asm_pc);

  return (h2_insn_t *)ptr;
}

#define SIGNALSIZE 6*44100 // 6 sec at 44,1 Khz

float signalIn[SIGNALSIZE], signalOut[SIGNALSIZE];

int main(int argc, char * argv[])
{
  h2_insn_t * ptr;
  float a1, a2, b0, b1, b2;
  piff fPtr;
  FILE * inFile, *outFile;
  char msg[]= "// Compilette for audio filtering\n";
  int nread;

  if (argc < 8)
    {
      printf("Give 5 floating point values and 2 filenames\n");
      printf("./biquadGive <b0> <b1> <b2> <a1> <a2> Infile.au OutFile.au\n");
      exit(-1);
    }
  b0  = atof (argv[1]);
  b1  = atof (argv[2]);
  b2  = atof (argv[3]);
  a1  = atof (argv[4]);
  a2  = atof (argv[5]);
  inFile = fopen (argv[6], "r");
  nread = fread (signalIn, sizeof (float), SIGNALSIZE, inFile);
  printf("%d sample read from %s\n", nread, argv[6]);
  fclose(inFile);
  /* ptr  = h2_malloc (1024);  // Allocate memory for 1024 instructions */
  /* fPtr = genFilter (ptr, b0, b1, b2, a1, a2); */
  /* res  = fPtr(in1, signalIn, signalOut);  // Call generated code */
  // Write audio file
  outFile = fopen (argv[7], "w");
  fwrite (signalOut, sizeof (float), SIGNALSIZE, outFile);
  fclose(outFile);
  return 0;
}
